<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Netty进阶学习</title>
    <link href="/2022/01/27/Netty%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/01/27/Netty%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">本文参考了码友 Nyima 的学习笔记<br>https:<span class="hljs-regexp">//</span>nyimac.gitee.io<span class="hljs-regexp">/2021/</span><span class="hljs-number">04</span><span class="hljs-regexp">/25/</span>Netty%E5%<span class="hljs-number">9</span>F%BA%E7%A1%<span class="hljs-number">80</span>/<br></code></pre></td></tr></table></figure><h1 id="一、粘包与半包"><a href="#一、粘包与半包" class="headerlink" title="一、粘包与半包"></a>一、粘包与半包</h1><h2 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接建立时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接断开时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stopped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> HelloServer().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup loopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(loopGroup);<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;connected...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-comment">// 每次发送16个字节的数据，共发送10次</span><br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                ByteBuf buffer = ctx.alloc().buffer();<br>                                buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>                                ctx.writeAndFlush(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            loopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-粘包现象"><a href="#3-粘包现象" class="headerlink" title="3. 粘包现象"></a>3. 粘包现象</h2><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">20</span>:08:<span class="hljs-number">59.269</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="hljs-number">0x7c21a326</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">1363</span>] READ: 160B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000020</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000030</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000040</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000050</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000060</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000070</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|00000080| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|00000090| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>+--------+-------------------------------------------------+----------------+<br><br></code></pre></td></tr></table></figure><h2 id="4-半包现象"><a href="#4-半包现象" class="headerlink" title="4. 半包现象"></a>4. 半包现象</h2><p>首先将客户端-服务器之间的 <strong>channel 容量</strong>进行调整，即在服务端中添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调整channel的容量</span><br>serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">5901</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: 36B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>|<span class="hljs-number">00000020</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">5901</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: 40B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................|<br>|<span class="hljs-number">00000010</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................|<br>|<span class="hljs-number">00000020</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">5901</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: 40B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b |................|<br>|<span class="hljs-number">00000010</span>| 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b |................|<br>|<span class="hljs-number">00000020</span>| 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span>                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">5901</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: 40B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................|<br>|<span class="hljs-number">00000010</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> |................|<br>|<span class="hljs-number">00000020</span>| <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">5901</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xc73284f3</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">49679</span>] READ: 4B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="①-注意"><a href="#①-注意" class="headerlink" title="①. 注意"></a>①. 注意</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">serverBootstrap<span class="hljs-selector-class">.option</span>(ChannelOption<span class="hljs-selector-class">.SO_RCVBUF</span>, <span class="hljs-number">10</span>) 影响的底层接收缓冲区（即滑动窗口）大小，<br>仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍<br></code></pre></td></tr></table></figure><h2 id="5-现象分析"><a href="#5-现象分析" class="headerlink" title="5. 现象分析"></a>5. 现象分析</h2><h3 id="①-粘包"><a href="#①-粘包" class="headerlink" title="①. 粘包"></a>①. 粘包</h3><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h3 id="②-半包"><a href="#②-半包" class="headerlink" title="②. 半包"></a>②. 半包</h3><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h3 id="③-本质"><a href="#③-本质" class="headerlink" title="③. 本质"></a>③. 本质</h3><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h2 id="6-解决方案"><a href="#6-解决方案" class="headerlink" title="6. 解决方案"></a>6. 解决方案</h2><h3 id="①-短链接"><a href="#①-短链接" class="headerlink" title="①. 短链接"></a>①. 短链接</h3><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。</p><p>这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。</p><p>但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改<code>public void channelActive(ChannelHandlerContext ctx)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>    ByteBuf buffer = ctx.alloc().buffer(<span class="hljs-number">16</span>);<br>    buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>    ctx.writeAndFlush(buffer);<br>    <span class="hljs-comment">// 使用短链接，每次发送完毕后就断开连接</span><br>    ctx.channel().close();<br>&#125;<br></code></pre></td></tr></table></figure><p>将发送步骤整体封装为<code>send()</code>方法，调用10次send()方法，模拟发送10次数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 发送10次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        send();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">6452</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x3eb6a684</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65024</span>] ACTIVE<br><br><span class="hljs-number">6468</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x3eb6a684</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65024</span>] READ: 16B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">6468</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x3eb6a684</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> ! R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65024</span>] INACTIVE<br><br><span class="hljs-number">6483</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x7dcc31ff</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65057</span>] ACTIVE<br><br><span class="hljs-number">6483</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x7dcc31ff</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65057</span>] READ: 16B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> 08 09 0a 0b 0c <span class="hljs-number">0d</span> 0e <span class="hljs-number">0f</span> |................|<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">6483</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x7dcc31ff</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> ! R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65057</span>] INACTIVE<br><br>...<br></code></pre></td></tr></table></figure><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h3 id="②-定长解码器"><a href="#②-定长解码器" class="headerlink" title="②. 定长解码器"></a>②. 定长解码器</h3><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。</p><p>若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。</p><p><strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意这个方法要加到业务handler的前面</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">16</span>));<br></code></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 约定最大长度为16</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">// 被发送的数据</span><br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-comment">// 向服务器发送10个报文</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        ByteBuf buffer = ctx.alloc().buffer(maxLength);<br>        <span class="hljs-comment">// 定长byte数组，未使用部分会以0进行填充</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[maxLength];<br>        <span class="hljs-comment">// 生成长度为0~15的数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(Math.random()*(maxLength-<span class="hljs-number">1</span>)); j++) &#123;<br>            bytes[j] = (<span class="hljs-keyword">byte</span>) c;<br>        &#125;<br>        buffer.writeBytes(bytes);<br>        c++;<br>        <span class="hljs-comment">// 将数据发送给服务器</span><br>        ctx.writeAndFlush(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过定长解码器对粘包数据进行拆分</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">16</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">8222</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xbc122d07</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52954</span>] READ: 16B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |aaaa............|<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">8222</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xbc122d07</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52954</span>] READ: 16B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |bbb.............|<br>+--------+-------------------------------------------------+----------------+<br><br><br><span class="hljs-number">8222</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0xbc122d07</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52954</span>] READ: 16B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">63</span> <span class="hljs-number">63</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |cc..............|<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure><h3 id="③-行解码器"><a href="#③-行解码器" class="headerlink" title="③. 行解码器"></a>③. 行解码器</h3><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 约定最大长度为 64</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 被发送的数据</span><br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        ByteBuf buffer = ctx.alloc().buffer(maxLength);<br>        <span class="hljs-comment">// 生成长度为0~62的数据</span><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>) (random.nextInt(maxLength - <span class="hljs-number">2</span>)); j++) &#123;<br>            sb.append(c);<br>        &#125;<br>        <span class="hljs-comment">// 数据以 \n 结尾</span><br>        sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br>        c++;<br>        <span class="hljs-comment">// 将数据发送给服务器</span><br>        ctx.writeAndFlush(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \n 为分隔符</span><br><span class="hljs-comment">// 需要指定最大长度</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">64</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">4184</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x9d6ac701</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">58282</span>] READ: 10B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span>                   |aaaaaaaaaa      |<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">4184</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x9d6ac701</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">58282</span>] READ: 11B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span>                |bbbbbbbbbbb     |<br>+--------+-------------------------------------------------+----------------+<br><br><span class="hljs-number">4184</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x9d6ac701</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">58282</span>] READ: 2B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">63</span> <span class="hljs-number">63</span>                                           |cc              |<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 约定最大长度为 64</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 被发送的数据</span><br>    <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        ByteBuf buffer = ctx.alloc().buffer(maxLength);<br>        <span class="hljs-comment">// 生成长度为0~62的数据</span><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>) (random.nextInt(maxLength - <span class="hljs-number">2</span>)); j++) &#123;<br>            sb.append(c);c<br>        &#125;<br>        <span class="hljs-comment">// 数据以 \c 结尾</span><br>        sb.append(<span class="hljs-string">&quot;\\c&quot;</span>);<br>        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br>        c++;<br>        <span class="hljs-comment">// 将数据发送给服务器</span><br>        ctx.writeAndFlush(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将分隔符放入ByteBuf中</span><br>ByteBuf bufSet = ch.alloc().buffer().writeBytes(<span class="hljs-string">&quot;\\c&quot;</span>.getBytes(StandardCharsets.UTF_8));<br><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \c 为分隔符</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> DelimiterBasedFrameDecoder(<span class="hljs-number">64</span>, ch.alloc().buffer().writeBytes(bufSet)));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">8246</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x86215ccd</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65159</span>] READ: 14B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span>       |aaaaaaaaaaaaaa  |<br>+--------+-------------------------------------------------+----------------+<br><br><br><span class="hljs-number">8247</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="hljs-number">0x86215ccd</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> - R:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">65159</span>] READ: 3B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span>                                        |bbb             |<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure><h3 id="④-LTC解码器"><a href="#④-LTC解码器" class="headerlink" title="④. LTC解码器"></a>④. LTC解码器</h3><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> maxFrameLength,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> lengthFieldOffset, <span class="hljs-keyword">int</span> lengthFieldLength,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> lengthAdjustment, <span class="hljs-keyword">int</span> initialBytesToStrip)</span></span><br></code></pre></td></tr></table></figure><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png" alt="img"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">lengthFieldOffset   = <span class="hljs-number">0</span><br>lengthFieldLength   = <span class="hljs-number">2</span><br>lengthAdjustment    = <span class="hljs-number">0</span><br>initialBytesToStrip = <span class="hljs-number">0</span> (= <span class="hljs-keyword">do</span> not strip header)<br>  <br><span class="hljs-function">BEFORE <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">14</span> bytes)</span>         AFTER <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">14</span> bytes)</span></span><br><span class="hljs-function">+--------+----------------+      +--------+----------------+</span><br><span class="hljs-function">| Length | Actual Content |-----&gt;| Length | Actual Content |</span><br><span class="hljs-function">| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |</span><br><span class="hljs-function">+--------+----------------+      +--------+----------------+</span><br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">lengthFieldOffset   = <span class="hljs-number">0</span><br>lengthFieldLength   = <span class="hljs-number">2</span><br>lengthAdjustment    = <span class="hljs-number">0</span><br>initialBytesToStrip = <span class="hljs-number">2</span> (= the length of the Length field)<br>  <br><span class="hljs-function">BEFORE <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">14</span> bytes)</span>         AFTER <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">12</span> bytes)</span></span><br><span class="hljs-function">+--------+----------------+      +----------------+</span><br><span class="hljs-function">| Length | Actual Content |-----&gt;| Actual Content |</span><br><span class="hljs-function">| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |</span><br><span class="hljs-function">+--------+----------------+      +----------------+</span><br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">lengthFieldOffset   = <span class="hljs-number">2</span> (= the length of Header <span class="hljs-number">1</span>)<br>lengthFieldLength   = <span class="hljs-number">3</span><br>lengthAdjustment    = <span class="hljs-number">0</span><br>initialBytesToStrip = <span class="hljs-number">0</span><br>  <br><span class="hljs-function">BEFORE <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">17</span> bytes)</span>                      AFTER <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">17</span> bytes)</span></span><br><span class="hljs-function">+----------+----------+----------------+      +----------+----------+----------------+</span><br><span class="hljs-function">| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |</span><br><span class="hljs-function">|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |</span><br><span class="hljs-function">+----------+----------+----------------+      +----------+----------+----------------+</span><br></code></pre></td></tr></table></figure><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">lengthFieldOffset   = <span class="hljs-number">0</span><br>lengthFieldLength   = <span class="hljs-number">3</span><br>lengthAdjustment    = <span class="hljs-number">2</span> (= the length of Header <span class="hljs-number">1</span>)<br>initialBytesToStrip = <span class="hljs-number">0</span><br>  <br><span class="hljs-function">BEFORE <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">17</span> bytes)</span>                      AFTER <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">17</span> bytes)</span></span><br><span class="hljs-function">+----------+----------+----------------+      +----------+----------+----------------+</span><br><span class="hljs-function">|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |</span><br><span class="hljs-function">| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |</span><br><span class="hljs-function">+----------+----------+----------------+      +----------+----------+----------------+</span><br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">lengthFieldOffset   = <span class="hljs-number">1</span> (= the length of HDR1)<br>lengthFieldLength   = <span class="hljs-number">2</span><br>lengthAdjustment    = <span class="hljs-number">1</span> (= the length of HDR2)<br>initialBytesToStrip = <span class="hljs-number">3</span> (= the length of HDR1 + LEN)<br>  <br><span class="hljs-function">BEFORE <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">16</span> bytes)</span>                       AFTER <span class="hljs-title">DECODE</span> <span class="hljs-params">(<span class="hljs-number">13</span> bytes)</span></span><br><span class="hljs-function">+------+--------+------+----------------+      +------+----------------+</span><br><span class="hljs-function">| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span><br><span class="hljs-function">| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |</span><br><span class="hljs-function">+------+--------+------+----------------+      +------+----------------+</span><br></code></pre></td></tr></table></figure><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，</p><p>即读取 <code>0xFE HELLO, WORLD</code></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NIO学习</title>
    <link href="/2022/01/26/NIO%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/26/NIO%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>通过画线理解同步阻塞、同步非阻塞、同步复用（多路复用）、异步非阻塞</p><h1 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h1><p><img src="/image/image-20220126173911097.png" alt="image-20220126173911097"></p><h1 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h1><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><p><img src="/image/image-20220126174012309.png" alt="image-20220126174012309"></p><h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><p><img src="/image/image-20220126174059130.png" alt="image-20220126174059130"></p><h1 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h1><p><img src="/image/image-20220126174201853.png" alt="image-20220126174201853"></p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty入门学习</title>
    <link href="/2022/01/24/Netty%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/01/24/Netty%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">本文参考了码友 Nyima 的学习笔记<br>https:<span class="hljs-regexp">//</span>nyimac.gitee.io<span class="hljs-regexp">/2021/</span><span class="hljs-number">04</span><span class="hljs-regexp">/25/</span>Netty%E5%<span class="hljs-number">9</span>F%BA%E7%A1%<span class="hljs-number">80</span>/<br></code></pre></td></tr></table></figure><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-什么是Netty"><a href="#1-什么是Netty" class="headerlink" title="1.  什么是Netty"></a>1.  什么是Netty</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端<br><br>Netty <span class="hljs-keyword">is</span> an asynchronous event-driven network <span class="hljs-built_in">application</span> framework<br><span class="hljs-keyword">for</span> rapid development <span class="hljs-keyword">of</span> maintainable high performance protocol servers &amp; clients.<br></code></pre></td></tr></table></figure><h2 id="2-注意"><a href="#2-注意" class="headerlink" title="2.  注意"></a>2.  注意</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO<br></code></pre></td></tr></table></figure><h2 id="3-优势"><a href="#3-优势" class="headerlink" title="3. 优势"></a>3. 优势</h2><h3 id="传统-NIO"><a href="#传统-NIO" class="headerlink" title="传统 NIO"></a>传统 NIO</h3><ul><li>工作量大</li><li>bug 多</li><li>需要自己构建协议</li><li>解决了 TCP 传输问题，如粘包、半包</li><li>因为 bug 的存在，会导致 epoll 空轮询导致 CPU 占用 100%</li></ul><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ul><li>API 增强，易于使用，不需要做大量重复事情</li><li>增强类，如：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">FastThreadLocal</span> =&gt; ThreadLocal<br><span class="hljs-attr">ByteBuf</span> =&gt; ByteBuffer<br></code></pre></td></tr></table></figure><h2 id="4-为什么Netty大量使用了异步？"><a href="#4-为什么Netty大量使用了异步？" class="headerlink" title="4. 为什么Netty大量使用了异步？"></a>4. 为什么Netty大量使用了异步？</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">简而言之就是，以响应速度换取了吞吐量<br>详情看 https:<span class="hljs-regexp">//</span>www.bilibili.com<span class="hljs-regexp">/video/</span>BV1py4y1E7oA?p=<span class="hljs-number">70</span>&amp;spm_id_from=pageDriver<br></code></pre></td></tr></table></figure><h2 id="5-读与写"><a href="#5-读与写" class="headerlink" title="5. 读与写"></a>5. 读与写</h2><p>我最初在认识上有这样的误区，认为只有在netty，nio这样的多路复用I0模型时，读写才不会相互阻塞才可以实现高效的双向通信，</p><p><strong>但实际上，Java Socket是全双工的：在任意时刻，线路上存在A到B和B到A的双向信号传输。</strong><br><strong>即使是阻塞lO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</strong></p><h1 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel nioSocketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(s);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;).bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        channel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                .sync()<br>                .channel()<br>                .writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/image/image-20220124230644911.png" alt="image-20220124230644911"></p><h1 id="三、重要组件"><a href="#三、重要组件" class="headerlink" title="三、重要组件"></a>三、重要组件</h1><h2 id="1-EventLoop-和-EventLoopGroup"><a href="#1-EventLoop-和-EventLoopGroup" class="headerlink" title="1. EventLoop 和 EventLoopGroup"></a>1. EventLoop 和 EventLoopGroup</h2><h3 id="①-EventLoopGroup"><a href="#①-EventLoopGroup" class="headerlink" title="①. EventLoopGroup"></a>①. EventLoopGroup</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs julia">事件循环组对象<br><br>本质上是一组EventLoop对象<br><span class="hljs-built_in">Channel</span> 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，<br>后续这个 <span class="hljs-built_in">Channel</span> 上的 <span class="hljs-built_in">IO</span> 事件都会由此 EventLoop 来处理<br>目的是为了保证 <span class="hljs-built_in">IO</span> 事件处理时的线程安全<br></code></pre></td></tr></table></figure><h4 id="Ⅰ-继承关系"><a href="#Ⅰ-继承关系" class="headerlink" title="Ⅰ. 继承关系"></a>Ⅰ. 继承关系</h4><p><img src="/image/image-20220125003702897.png" alt="image-20220125003702897"></p><h5 id="EventExecutorGroup"><a href="#EventExecutorGroup" class="headerlink" title="EventExecutorGroup"></a>EventExecutorGroup</h5><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">实现了 Iterable 接口提供遍历 EventLoop 的能力<br>另有 <span class="hljs-keyword">next</span> 方法获取集合中下一个 EventLoop<br></code></pre></td></tr></table></figure><h3 id="②-EventLoop"><a href="#②-EventLoop" class="headerlink" title="②. EventLoop"></a>②. EventLoop</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs julia">事件循环对象<br><br>本质上是一个单线程执行器（同时维护了一个 Selector），<br>里面有 run 方法处理 <span class="hljs-built_in">Channel</span> 上源源不断的 <span class="hljs-built_in">IO</span> 事件<br></code></pre></td></tr></table></figure><h4 id="Ⅰ-继承关系-1"><a href="#Ⅰ-继承关系-1" class="headerlink" title="Ⅰ.  继承关系"></a>Ⅰ.  继承关系</h4><p><img src="/image/image-20220125002442025.png" alt="image-20220125002442025"></p><h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">提供了线程池中的所有方法<br></code></pre></td></tr></table></figure><h5 id="OrderedEventExecutor"><a href="#OrderedEventExecutor" class="headerlink" title="OrderedEventExecutor"></a>OrderedEventExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">提供了 <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">inEventLoop</span><span class="hljs-params">(Thread thread)</span> 方法判断一个线程是否属于 EventLoop</span><br><span class="hljs-function">提供了 parent 方法来看看自己属于哪个 EventLoopGroup</span><br></code></pre></td></tr></table></figure><h3 id="③-普通任务"><a href="#③-普通任务" class="headerlink" title="③. 普通任务"></a>③. 普通任务</h3><h4 id="Ⅰ-代码"><a href="#Ⅰ-代码" class="headerlink" title="Ⅰ. 代码"></a>Ⅰ. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultTaskTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// DefaultEventLoopGroup group1 = new DefaultEventLoopGroup(); 普通，定时任务</span><br><br>        <span class="hljs-comment">// io 事件，普通，定时任务</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// next方法实现了一个轮询，达到负载均衡效果</span><br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        <span class="hljs-comment">// 执行普通任务，异步处理，提高工作效率</span><br>        group.next().submit(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125;);<br>        group.next().submit(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125;);<br>        log.debug(<span class="hljs-string">&quot;main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220125214434144.png" alt="image-20220125214434144"></p><h3 id="④-定时任务"><a href="#④-定时任务" class="headerlink" title="④. 定时任务"></a>④. 定时任务</h3><h4 id="Ⅰ-代码-1"><a href="#Ⅰ-代码-1" class="headerlink" title="Ⅰ. 代码"></a>Ⅰ. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimingTaskTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// DefaultEventLoopGroup group1 = new DefaultEventLoopGroup(); 普通，定时任务</span><br><br>        <span class="hljs-comment">// io 事件，普通，定时任务</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// next方法实现了一个轮询，达到负载均衡效果</span><br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        System.out.println(group.next());<br>        <span class="hljs-comment">// 执行定时任务，异步处理，每隔 1 秒打印一个 ok</span><br>        group.next().scheduleAtFixedRate(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        log.debug(<span class="hljs-string">&quot;main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220125214905102.png" alt="image-20220125214905102"></p><h3 id="⑤-IO任务"><a href="#⑤-IO任务" class="headerlink" title="⑤. IO任务"></a>⑤. IO任务</h3><h4 id="Ⅰ-客户端代码"><a href="#Ⅰ-客户端代码" class="headerlink" title="Ⅰ. 客户端代码"></a>Ⅰ. 客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOTestClientTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Channel channel = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                .sync()<br>                .channel();<br>        System.out.println(channel);<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ⅱ-服务端代码"><a href="#Ⅱ-服务端代码" class="headerlink" title="Ⅱ. 服务端代码"></a>Ⅱ. 服务端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOTaskServerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                log.debug(buf.toString(Charset.defaultCharset()));<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220125220755942.png" alt="image-20220125220755942"></p><p><img src="/image/image-20220125220905355.png" alt="image-20220125220905355"></p><h3 id="⑥-分工细化"><a href="#⑥-分工细化" class="headerlink" title="⑥. 分工细化"></a>⑥. 分工细化</h3><h4 id="Ⅰ-服务端代码"><a href="#Ⅰ-服务端代码" class="headerlink" title="Ⅰ. 服务端代码"></a>Ⅰ. 服务端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DivisionOfLaborTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 细分2. 创建一个独立的 EventLoopGroup</span><br>        DefaultEventLoopGroup group = <span class="hljs-keyword">new</span> DefaultEventLoopGroup();<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                <span class="hljs-comment">//细分1.     ParentGroup 负责 accept    childrenGroup 负责 读写</span><br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(), <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>))<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-string">&quot;handler1&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                log.debug(buf.toString(Charset.defaultCharset()));<br>                                ctx.fireChannelRead(msg);<br>                            &#125;<br>                            <span class="hljs-comment">// 切换为另一个 EventLoopGroup</span><br>                        &#125;).addLast(group, <span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                log.debug(buf.toString(Charset.defaultCharset()));<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220125223117832.png" alt="image-20220125223117832"></p><h3 id="⑦-切换线程的原理"><a href="#⑦-切换线程的原理" class="headerlink" title="⑦. 切换线程的原理"></a>⑦. 切换线程的原理</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">在 ⑥. 分工细化中， 出现了 ha<span class="hljs-symbol">ndler1</span> 线程转换为 ha<span class="hljs-symbol">ndler2</span> 线程，其原理如下：<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>    <span class="hljs-comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span><br>    EventExecutor executor = next.executor();<br>    <br>    <span class="hljs-comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span><br>        next.invokeChannelRead(m);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span><br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">简而言之就是，如果两个 <span class="hljs-keyword">handler</span> 绑定的是同一个线程，那么就直接调用<br>否则，把要调用的代码封装为一个任务对象，由下一个 <span class="hljs-keyword">handler</span> 的线程来执行<br></code></pre></td></tr></table></figure><h2 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="①-ChannelFuture"><a href="#①-ChannelFuture" class="headerlink" title="①. ChannelFuture"></a>①. ChannelFuture</h3><h4 id="Ⅰ-同步连接"><a href="#Ⅰ-同步连接" class="headerlink" title="Ⅰ. 同步连接"></a>Ⅰ. 同步连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynConnectionChannelFutureTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br><br>        <span class="hljs-comment">// 该方法用于等待连接真正建立</span><br>        channelFuture.sync();<br><br>        <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span><br>        Channel channel = channelFuture.channel();<br>        channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><h4 id="Ⅱ-异步连接"><a href="#Ⅱ-异步连接" class="headerlink" title="Ⅱ. 异步连接"></a>Ⅱ. 异步连接</h4><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncConnectionChannelFutureTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br><br>        <span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span><br>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span><br>        channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Channel channel = channelFuture.channel();<br>                channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ⅲ-同步关闭"><a href="#Ⅲ-同步关闭" class="headerlink" title="Ⅲ. 同步关闭"></a>Ⅲ. 同步关闭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynCloseChannelFutureClientTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;).connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        Channel channel = channelFuture.sync().channel();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                String line = scanner.nextLine();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(line)) &#123;<br>                    channel.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                channel.writeAndFlush(line);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;input&quot;</span>).start();<br>        <span class="hljs-comment">// 获取 ClosedFuture 对象</span><br>        ChannelFuture closeFuture = channel.closeFuture();<br>        System.out.println(<span class="hljs-string">&quot;等待关闭&quot;</span>);<br>        closeFuture.sync();<br>        System.out.println(<span class="hljs-string">&quot;处理关闭之后的操作&quot;</span>);<br>        <span class="hljs-comment">// 优雅的关闭 group 内的线程</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220126160840875.png" alt="image-20220126160840875"></p><h4 id="Ⅳ-异步关闭"><a href="#Ⅳ-异步关闭" class="headerlink" title="Ⅳ. 异步关闭"></a>Ⅳ. 异步关闭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCloseChannelFutureClientTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;).connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        Channel channel = channelFuture.sync().channel();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                String line = scanner.nextLine();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(line)) &#123;<br>                    channel.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                channel.writeAndFlush(line);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;input&quot;</span>).start();<br>        <span class="hljs-comment">// 获取 ClosedFuture 对象</span><br>        ChannelFuture closeFuture = channel.closeFuture();<br>        System.out.println(<span class="hljs-string">&quot;等待关闭&quot;</span>);<br>        closeFuture.addListener((ChannelFutureListener) channelFuture1 -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;处理关闭之后的操作&quot;</span>);<br>            <span class="hljs-comment">// 优雅的关闭 group 内的线程</span><br>            group.shutdownGracefully();<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220126161249302.png" alt="image-20220126161249302"></p><h4 id="Ⅴ-优雅地关闭"><a href="#Ⅴ-优雅地关闭" class="headerlink" title="Ⅴ. 优雅地关闭"></a>Ⅴ. 优雅地关闭</h4><p>在上述两种关闭期间 输入 <code>q</code> 后并不会使服务真正地关闭</p><p>是因为 <strong>NioEventLoopGroup</strong> 仍存在线程<strong>未被关闭</strong></p><p>所以可以使用 <code>shutdownGracefully()</code> 方法进行关闭</p><h2 id="3-Future-和-Promise"><a href="#3-Future-和-Promise" class="headerlink" title="3. Future 和 Promise"></a>3. Future 和 Promise</h2><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="①-JDK-的-Future"><a href="#①-JDK-的-Future" class="headerlink" title="①. JDK 的 Future"></a>①. JDK 的 Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDKFutureTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 1.线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 2.提交任务</span><br>        Future&lt;Integer&gt; future = executorService.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行计算&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>        &#125;);<br>        <span class="hljs-comment">// 3.主线程通过 future 来获取结果</span><br>        System.out.println(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span> + future.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220126205254634.png" alt="image-20220126205254634"></p><h3 id="②-Netty-的-Future"><a href="#②-Netty-的-Future" class="headerlink" title="②. Netty 的 Future"></a>②. Netty 的 Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyFutureTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        async();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoop eventLoop = group.next();<br>        Future&lt;Integer&gt; future = eventLoop.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行计算&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">70</span>;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span> + future.get());<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">async</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoop eventLoop = group.next();<br>        Future&lt;Integer&gt; future = eventLoop.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;执行计算&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">70</span>;<br>        &#125;);<br>        future.addListener(<span class="hljs-keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="hljs-keyword">super</span> Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-keyword">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;结果是：&quot;</span> + future.get());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="③-Netty-的-Promise"><a href="#③-Netty-的-Promise" class="headerlink" title="③. Netty 的 Promise"></a>③. Netty 的 Promise</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyPromiseTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 1. 准备 EventLoop 对象</span><br>        EventLoop eventLoop = <span class="hljs-keyword">new</span> NioEventLoopGroup().next();<br>        <span class="hljs-comment">// 2. 可以主动创建 promise 结果容器对象</span><br>        DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);<br>        <span class="hljs-comment">// 3. 启动一个线程执行计算，计算完毕后向 promise 中填入结果</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;开始计算&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            promise.setSuccess(<span class="hljs-number">80</span>);<br>        &#125;).start();<br>        <span class="hljs-comment">// 4. 接收结果的线程</span><br>        log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;结果是：&#123;&#125;&quot;</span>, promise.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-PipeLine-和-Handler"><a href="#4-PipeLine-和-Handler" class="headerlink" title="4. PipeLine 和 Handler"></a>4. PipeLine 和 Handler</h2><p><code>ChannelHandler</code> 用来处理 <code>Channel</code> 上的各种事件，分为<strong>入站、出站</strong>两种。</p><p>所有 <code>ChannelHandler</code> 被连成—串，就是 Pipeline</p><ul><li>入站处理器通常是 <code>ChannellnboundHandlerAdapter</code> 的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是 <code>ChannelOutboundHandlerAdapter</code> 的子类，主要对写回结果进行加工</li></ul><p>打个比喻，每个 <code>Channel</code> 是一个产品的加工车间，管道是车间中的流水线，<code>ChanneHandler</code> 就是流水线上的各道工序，而后面要讲的 <code>ByteBuf</code> 是原材料，经过很多工序的加工:先经过一道道入站工序，再经过一道道出站工序最终变成产品</p><h3 id="①-Pipeline"><a href="#①-Pipeline" class="headerlink" title="①. Pipeline"></a>①. Pipeline</h3><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。</p><p>这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PipelineTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 1. 通过 Channel 拿到 pipeline</span><br>                        ChannelPipeline pipeline = ch.pipeline();<br>                        <span class="hljs-comment">// 2. 为 pipeline 添加 处理器     head -&gt; h1 -&gt; tail</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// head -&gt; h1 -&gt; h2 -&gt; tail</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;h2&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; tail</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;h3&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>                                <span class="hljs-comment">// 3. 触发写事件</span><br>                                ch.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="hljs-string">&quot;server&quot;</span>.getBytes()));<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; tail</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;h4&quot;</span>, <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                log.debug(<span class="hljs-string">&quot;4&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; h5 -&gt; tail</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;h5&quot;</span>, <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                log.debug(<span class="hljs-string">&quot;5&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; h5 -&gt; h6 -&gt; tail</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;h6&quot;</span>, <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                log.debug(<span class="hljs-string">&quot;6&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220126220718364.png" alt="image-20220126220718364"></p><h4 id="Ⅰ-结构"><a href="#Ⅰ-结构" class="headerlink" title="Ⅰ. 结构"></a>Ⅰ. 结构</h4><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会<strong>从head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会<strong>从tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png" alt="img"></p><h4 id="Ⅱ-调用顺序"><a href="#Ⅱ-调用顺序" class="headerlink" title="Ⅱ. 调用顺序"></a>Ⅱ. 调用顺序</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png" alt="img"></p><h3 id="②-Handler"><a href="#②-Handler" class="headerlink" title="②. Handler"></a>②. Handler</h3><h4 id="Ⅰ-OutboundHandler"><a href="#Ⅰ-OutboundHandler" class="headerlink" title="Ⅰ. OutboundHandler"></a>Ⅰ. OutboundHandler</h4><p><code>socketChannel.writeAndFlush()</code></p><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png" alt="img"></p><p><code>ctx.writeAndFlush()</code></p><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png" alt="img"></p><h4 id="Ⅱ-EmbeddedChannel"><a href="#Ⅱ-EmbeddedChannel" class="headerlink" title="Ⅱ. EmbeddedChannel"></a>Ⅱ. EmbeddedChannel</h4><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedChannelTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ChannelInboundHandlerAdapter h1 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        ChannelInboundHandlerAdapter h2 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h3 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h4 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 用于测试Handler的Channel</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(h1, h2, h3, h4);<br><br>        <span class="hljs-comment">// 执行Inbound操作</span><br>        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">// 执行Outbound操作</span><br>        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-ByteBuf"><a href="#5-ByteBuf" class="headerlink" title="5. ByteBuf"></a>5. ByteBuf</h2><h3 id="①-创建"><a href="#①-创建" class="headerlink" title="①. 创建"></a>①. 创建</h3><p><strong>ButyBuf空间日志打印工具类</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">该方法可以帮助我们更为详细地查看ByteBuf中的内容<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufLogUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(ByteBuf buffer)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = buffer.readableBytes();<br>        <span class="hljs-keyword">int</span> rows = length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>        StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)<br>                .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.readerIndex())<br>                .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writerIndex())<br>                .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity())<br>                .append(NEWLINE);<br>        appendPrettyHexDump(buf, buffer);<br>        System.out.println(buf.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufAllocatorTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();<br>        log(buffer);<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>        buffer.writeBytes(stringBuilder.toString().getBytes());<br>        log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="②-直接内存和堆内存"><a href="#②-直接内存和堆内存" class="headerlink" title="②. 直接内存和堆内存"></a>②. 直接内存和堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HeapAndDirectTest</span><span class="hljs-params">()</span></span>&#123;<br>    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>    System.out.println(buffer.getClass());<br><br>    buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br>    System.out.println(buffer.getClass());<br><br>    buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br>    System.out.println(buffer.getClass());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用池化的直接内存</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeDirectByteBuf</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">// 使用池化的堆内存    </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeHeapByteBuf</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">// 使用池化的直接内存    </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeDirectByteBuf</span></span><br></code></pre></td></tr></table></figure><h3 id="③-池化与非池化"><a href="#③-池化与非池化" class="headerlink" title="③. 池化与非池化"></a>③. 池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">-<span class="hljs-type">Dio</span>.netty.allocator.<span class="hljs-keyword">type</span>=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="④-组成"><a href="#④-组成" class="headerlink" title="④. 组成"></a>④. 组成</h3><p>ByteBuf 主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造 ByteBuf 时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为<code>Integer.MAX_VALUE</code></li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于 ByteBuffer 只用 position 进行控制，</p><p>ByteBuf分别由<strong>读指针</strong>和<strong>写指针</strong>两个指针控制</p><p>。进行读写操作时，<strong>无需进行模式的切换</strong></p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png" alt="img"></p><h3 id="⑤-写入"><a href="#⑤-写入" class="headerlink" title="⑤. 写入"></a>⑤. 写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td><strong>Big Endian（大端写入）</strong>，即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td><strong>Little Endian（小端写入）</strong>，即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据，默认是 Big Endian 从高位开始写</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeInt(<span class="hljs-number">5</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeIntLE(<span class="hljs-number">6</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeLong(<span class="hljs-number">7</span>);<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">0</span> capacity:<span class="hljs-number">16</span><br><br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">4</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">12</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             |............    |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">20</span> capacity:<span class="hljs-number">20</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |................|<br>|<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="⑥-扩容"><a href="#⑥-扩容" class="headerlink" title="⑥. 扩容"></a>⑥. 扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeLong(<span class="hljs-number">7</span>);<br>ByteBufUtil.log(buffer);<br><span class="hljs-comment">// 扩容前</span><br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">12</span> capacity:<span class="hljs-number">16</span><br>...<br><br><span class="hljs-comment">// 扩容后</span><br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">20</span> capacity:<span class="hljs-number">20</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> |................|<br>|<span class="hljs-number">00000010</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容<ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li>如果写入后数据大小超过 512 字节，则选择下一个 2^n<ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 2^10=1024 字节（2^9=512 已经不够了）</li></ul></li><li>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IndexOutOfBoundsException: writer<span class="hljs-constructor">Index(20)</span> + min<span class="hljs-constructor">WritableBytes(8)</span> exceeds max<span class="hljs-constructor">Capacity(20)</span>: <span class="hljs-constructor">PooledUnsafeDirectByteBuf(<span class="hljs-params">ridx</span>: 0, <span class="hljs-params">widx</span>: 20, <span class="hljs-params">cap</span>: 20<span class="hljs-operator">/</span>20)</span><br>...<br></code></pre></td></tr></table></figure><h3 id="⑦-读取"><a href="#⑦-读取" class="headerlink" title="⑦. 读取"></a>⑦. 读取</h3><p>读取主要是通过一系列 read 方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        buffer.writeInt(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 读取4个字节</span><br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 通过mark与reset实现重复读取</span><br>        buffer.markReaderIndex();<br>        System.out.println(buffer.readInt());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 恢复到mark标记处</span><br>        buffer.resetReaderIndex();<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">5</span><br>read index:<span class="hljs-number">8</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="⑧-释放"><a href="#⑧-释放" class="headerlink" title="⑧. 释放"></a>⑧. 释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>Unpooled<strong>Heap</strong>ByteBuf 使用的是 <strong>JVM</strong> 内存，只需等 GC 回收内存即可</li><li>Unpooled<strong>Direct</strong>ByteBuf 使用的就是<strong>直接内存</strong>了，需要特殊的方法来回收内存</li><li><strong>Pooled</strong>ByteBuf 和它的子类使用了<strong>池化机制</strong>，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，<strong>如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性</strong>（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!buffer.release()) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 具体的释放方法</span><br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br><span class="hljs-keyword">return</span> msg <span class="hljs-keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="⑨-切片"><a href="#⑨-切片" class="headerlink" title="⑨. 切片"></a>⑨. 切片</h3><h4 id="Ⅰ-slice"><a href="#Ⅰ-slice" class="headerlink" title="Ⅰ. slice"></a>Ⅰ. slice</h4><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png" alt="img"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufSliceTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>&#125;);<br><br>        <span class="hljs-comment">// 将buffer分成两部分</span><br>        ByteBuf slice1 = buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        ByteBuf slice2 = buffer.slice(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span><br>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span><br>        slice1.retain();<br>        slice2.retain();<br><br>        log(slice1);<br>        log(slice2);<br><br>        <span class="hljs-comment">// 更改原始buffer中的值</span><br>        System.out.println(<span class="hljs-string">&quot;===========修改原buffer中的值===========&quot;</span>);<br>        buffer.setByte(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;===========打印slice1===========&quot;</span>);<br>        log(slice1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">5</span> capacity:<span class="hljs-number">5</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span>                                  |abcde           |<br>+--------+-------------------------------------------------+----------------+<br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">5</span> capacity:<span class="hljs-number">5</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">66</span> <span class="hljs-number">67</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> 6a                                  |fghij           |<br>+--------+-------------------------------------------------+----------------+<br>===========修改原buffer中的值===========<br>===========打印slice1===========<br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">5</span> capacity:<span class="hljs-number">5</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span>                                  |bbcde           |<br>+--------+-------------------------------------------------+----------------+<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="Ⅱ-duplicate"><a href="#Ⅱ-duplicate" class="headerlink" title="Ⅱ. duplicate"></a>Ⅱ. duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p><p><img src="/image/image-20220127165007710.png" alt="image-20220127165007710"></p><h4 id="Ⅲ-copy"><a href="#Ⅲ-copy" class="headerlink" title="Ⅲ. copy"></a>Ⅲ. copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p><h3 id="⑩-合成"><a href="#⑩-合成" class="headerlink" title="⑩. 合成"></a>⑩. 合成</h3><p>与切片是相反操作，<strong>是将多个 ByteBuf 碎片，合成为一个ByteBuf</strong>，同时在合成过程中也<strong>不会发生数据的拷贝</strong></p><h4 id="Ⅰ-composite"><a href="#Ⅰ-composite" class="headerlink" title="Ⅰ. composite"></a>Ⅰ. composite</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufCompositeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer();<br>        buf1.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;);<br>        ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer();<br>        buf1.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>&#125;);<br><br>        CompositeByteBuf buffs = ByteBufAllocator.DEFAULT.compositeBuffer();<br>        buffs.addComponents(<span class="hljs-keyword">true</span>, buf1, buf2);<br>        log(buffs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">10</span> capacity:<span class="hljs-number">10</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">63</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">66</span> <span class="hljs-number">67</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> 6a                   |abcdefghij      |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="⑪-优势"><a href="#⑪-优势" class="headerlink" title="⑪. 优势"></a>⑪. 优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>可以将各大重要组件分为三大类：</p><h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><h4 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h4><p>负责客户端启动，并且去连接远程的Netty Server</p><h4 id="ServerBootStrap"><a href="#ServerBootStrap" class="headerlink" title="ServerBootStrap"></a>ServerBootStrap</h4><p>负责服务端的监听，用来监听指定的一个端口</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>负责网络通信的一个载体</p><h3 id="事件调度层"><a href="#事件调度层" class="headerlink" title="事件调度层"></a>事件调度层</h3><h4 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h4><p>本质上是一个线程池，主要去负责接收IO请求，并分配线程去执行处理请求</p><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>是<code>EventLoopGroup</code>线程池中的一个具体线程</p><h3 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h3><h4 id="ChannelPipeLine"><a href="#ChannelPipeLine" class="headerlink" title="ChannelPipeLine"></a>ChannelPipeLine</h4><p>负责处理多个<code>ChannelHandler</code>，将多个<code>ChannelHandler</code>构成一个执行链，从而实现流水线的效果</p><h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p>针对 IO 数据的一个处理器，数据处理接收后通过指定的 <code>Handler</code> 进行处理</p><h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>用来保存<code>ChannelHandler</code>上下文信息</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper主从服务器之间的数据同步</title>
    <link href="/2022/01/24/%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/01/24/%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/image-20220118013056649.png" alt="image-20220118013056649"></p><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">主节点通过ZAB向子节点发送数据确保数据一致性<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>选举机制</title>
    <link href="/2022/01/24/%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/01/24/%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="启动时选举"><a href="#启动时选举" class="headerlink" title="启动时选举"></a>启动时选举</h1><p><img src="/image/image-20220118003853321.png" alt="image-20220118003853321"></p><h2 id="从配置文件中读取集群个数"><a href="#从配置文件中读取集群个数" class="headerlink" title="从配置文件中读取集群个数"></a>从配置文件中读取集群个数</h2><figure class="highlight axapta"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs axapta">从.cfg文件中读取<span class="hljs-keyword">server</span>的个数，以便在过半时选出leader<br></code></pre></td></tr></table></figure><h2 id="交换票"><a href="#交换票" class="headerlink" title="交换票"></a>交换票</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">每台服务器把自己的票（myid和zxid）投给参与选举的节点<br></code></pre></td></tr></table></figure><h2 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">将自己手上比较大的票投出去<br>先比较zxid，再比较myid<br>因为zxid代表着事务<span class="hljs-built_in">id</span>，在这台Zookeeper服务器上每当有一个数改变，zxid就会加一，为了保证数据一致，就优先选择zxid<br><br>直到投票箱的数额超过集群一半<br></code></pre></td></tr></table></figure><h2 id="选举Leader"><a href="#选举Leader" class="headerlink" title="选举Leader"></a>选举Leader</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">选举得票数最高的为<span class="hljs-built_in">Leader</span><br></code></pre></td></tr></table></figure><h2 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h2><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">有的节点在<span class="hljs-built_in">Leader</span>诞生之后才连接上集群，此时如果发现以及存在<span class="hljs-built_in">Leader</span>，便不会再参与投票，而是直接成为Follower<br></code></pre></td></tr></table></figure><h1 id="崩溃恢复时选举"><a href="#崩溃恢复时选举" class="headerlink" title="崩溃恢复时选举"></a>崩溃恢复时选举</h1><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">Leader</span>建立完后，<span class="hljs-built_in">Leader</span>周期性地不断向Follow发送心跳（ping命令，没有内容地socket）。<br>当<span class="hljs-built_in">Leader</span>崩溃后，Follower发现socket通道已关闭，于是Follower开始进入到Looking状态，重新回到上一节中的<span class="hljs-built_in">Leader</span>选举状态，此时集群不能对外访问<br></code></pre></td></tr></table></figure><h2 id="ping失败"><a href="#ping失败" class="headerlink" title="ping失败"></a>ping失败</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">发现<span class="hljs-built_in">ping</span>多次失败后，异常报错<br></code></pre></td></tr></table></figure><h2 id="重新选举"><a href="#重新选举" class="headerlink" title="重新选举"></a>重新选举</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">Follower开始进入倒Looking状态<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>谈谈对Zookeeper的理解</title>
    <link href="/2022/01/24/%E8%B0%88%E8%B0%88%E5%AF%B9Zookeeper%E7%90%86%E8%A7%A3/"/>
    <url>/2022/01/24/%E8%B0%88%E8%B0%88%E5%AF%B9Zookeeper%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>应用场景</p><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">从三种典型的应用场景介绍<br></code></pre></td></tr></table></figure><h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在多个节点组成的集群中，为了保证集群的HA（Highly Available）的特性，每个节点都需要冗余一份数据副本，这种情况下需要保证客户端访问集群中的任意一个节点都是最新的数据<br></code></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Zookeeper</span>提供了<span class="hljs-meta">CP</span>模型，来保证集群中的每一个节点的数据一致性，需要调用sync方法进行数据同步，但是Zookeeper并不是一个强一致性模型，而是一个顺序一致性模型<br></code></pre></td></tr></table></figure><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">为了保证跨进程的共享资源的并发安全性，就必须使用跨进程的锁，也就是分布式锁<br></code></pre></td></tr></table></figure><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.通过有序节点的特性实现<br>2.同一级节点的唯一特性<br></code></pre></td></tr></table></figure><h2 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">在多个节点组成的集群中，为了降低集群数据同步的复杂度，会存在<span class="hljs-literal">Master</span>和<span class="hljs-literal">Slave</span>两种角色的节点<br><span class="hljs-literal">Master</span>负责事务和非事务性的请求处理<br><span class="hljs-literal">Slave</span>负责非事务性的请求处理<br>但是分布式中如何去确定某个节点是<span class="hljs-literal">Master</span>还是<span class="hljs-literal">Slave</span><br></code></pre></td></tr></table></figure><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">1</span>.通过持久性节点存储和管理其他集群节点的一些信息，从而进行<span class="hljs-literal">Master</span>选举机制<br><span class="hljs-number">2</span>.有序节点的特性来实现<span class="hljs-literal">Master</span>选举机制<br></code></pre></td></tr></table></figure><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">针对上诉情况，产生了Zookeeper这样一个中间件，是一个分布式开源协调组件，类似于一个裁判员的身份，专门负责协调和解决分布式系统中的各类问题<br><br>总的来说，Zookeeper本就是一个经典的分布式数据一致性的解决方案组件，主要致力于分布式应用中的一些高性能、高可用的并且具有严格访问顺序控制的一些能力模型，来实现分布式协调服务<br><br>它底层的数据一致性算法，是基于Paxos算法演进而来的ZAB协议实现<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>节点类型</title>
    <link href="/2022/01/24/%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/01/24/%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="持久化节点"><a href="#持久化节点" class="headerlink" title="持久化节点"></a>持久化节点</h1><figure class="highlight gauss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">create</span> /xxx<br></code></pre></td></tr></table></figure><h1 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h1><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> -<span class="hljs-built_in">e</span> /xxx<br></code></pre></td></tr></table></figure><h1 id="有序节点"><a href="#有序节点" class="headerlink" title="有序节点"></a>有序节点</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">create</span> -s /xxx<br></code></pre></td></tr></table></figure><h1 id="容器节点"><a href="#容器节点" class="headerlink" title="容器节点"></a>容器节点</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">create</span> -c /xxx<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ZAB协议</title>
    <link href="/2022/01/24/ZAB%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/01/24/ZAB%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs sql">Zookeeper作为非常重要的分布式协调组件，需要进行集群部署，集群中会以一主多从的形式进行部署。<br>Zookeeper为了保证数据的一致性，使用了ZAB（Zookeeper <span class="hljs-keyword">Atomic</span> Broadcast）协议，这个协议解决了Zookeeper的崩溃恢复和主从数据同步的问题<br></code></pre></td></tr></table></figure><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.保证数据的一致性<br>2.崩溃恢复<br></code></pre></td></tr></table></figure><h1 id="定义的四种节点状态"><a href="#定义的四种节点状态" class="headerlink" title="定义的四种节点状态"></a>定义的四种节点状态</h1><p>Looking：选举状态</p><p>Following：从节点状态</p><p>Leading：主节点状态</p><p>Observing：观察者状态，不参与选举</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CAP理论</title>
    <link href="/2022/01/24/CAP%E7%90%86%E8%AE%BA/"/>
    <url>/2022/01/24/CAP%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">CAP理论为：<br><span class="hljs-bullet">1.</span> Consistency 一致性<br><span class="hljs-bullet">2.</span> Availability 可用性<br><span class="hljs-bullet">3.</span> Partition tolerance 分区容错性（分布式项目必选）<br><br>最多只能满足上述的其中两项<br></code></pre></td></tr></table></figure><h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">All nodes see <span class="hljs-keyword">the</span> same data <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> same <span class="hljs-built_in">time</span><br>所有节点在同一时间对外开发完全一样的数据<br></code></pre></td></tr></table></figure><h1 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Reads</span> <span class="hljs-keyword">and</span> writes always succeed <br>读写操作总是成功，服务一直可用<br></code></pre></td></tr></table></figure><h1 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以集群来分担压力<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主从复制原理</title>
    <link href="/2022/01/24/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/24/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h1><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 主节点通过bgsave命令fork子进程进行RDB持久化，该过程非常消耗CPU、内存（页表复制）、磁盘I/O<br><br><span class="hljs-bullet">2.</span> 主节点通过网络将RDB文件发送给从节点，对主节点的带框会带来很大的消耗<br><br><span class="hljs-bullet">3.</span> 从节点清空老数据、载入新RDB文件，其过程是阻塞的，无法响应客户端命令；如果从节点执行bgrewriteaof，也会带来额外的消耗<br></code></pre></td></tr></table></figure><h1 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1.</span> 复制偏移量：执行复制的主从节点，分别会维护一个偏移量<span class="hljs-built_in">offset</span>，用来记录下一次同步从哪儿开始<br><br><span class="hljs-number">2.</span> 复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出的队列作为复制积压缓冲区，当主从节点<span class="hljs-built_in">offset</span>的差距过大超过缓冲区时，将无法执行部分复制，只能执行全量复制<br>使用缓冲区可以避免从节点要去主节点的硬盘中获取数据<br><br><span class="hljs-number">3.</span> 每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID保存起来。从节点Redis断开重连的时候，就会根据运行ID来判断同步的进度：<br><span class="hljs-number">3.1</span>. 如果从节点保存的运行ID与主节点的运行ID相同，说明主从节点之前同步过，主节点会继续尝试使用增量复制（到底能不能复制还得  看<span class="hljs-built_in">offset</span>和复制积压缓冲区的情况） <br><span class="hljs-number">3.2</span>. 如果从节点保存的运行ID与主节点的运行ID不相同，说明从节点在断开前同步的Redis节点并不是当前的主节点，只能进行全量复制<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220117154106931.png" alt="image-20220117154106931"></p><h1 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h1><p><img src="/image/image-20220117154754090.png" alt="image-20220117154754090"></p>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么Redis非常快</title>
    <link href="/2022/01/24/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E9%9D%9E%E5%B8%B8%E5%BF%AB/"/>
    <url>/2022/01/24/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E9%9D%9E%E5%B8%B8%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="基于内存"><a href="#基于内存" class="headerlink" title="基于内存"></a>基于内存</h1><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">绝大部分请求都是纯粹的内存操作。<br></code></pre></td></tr></table></figure><h1 id="数据结构简单"><a href="#数据结构简单" class="headerlink" title="数据结构简单"></a>数据结构简单</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对数据操作非常简单<br></code></pre></td></tr></table></figure><h1 id="采用单线程"><a href="#采用单线程" class="headerlink" title="采用单线程"></a>采用单线程</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">避免了多线程上下文切换和竞争产生的消耗<br></code></pre></td></tr></table></figure><h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">使用了多路<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>复用模型，非阻塞<span class="hljs-variable">IO</span><br></code></pre></td></tr></table></figure><h1 id="底层模型"><a href="#底层模型" class="headerlink" title="底层模型"></a>底层模型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>九大数据结构</title>
    <link href="/2022/01/24/%E4%B9%9D%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/24/%E4%B9%9D%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><figure class="highlight gauss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs gauss">一个<span class="hljs-built_in">key</span>对应一个value<br><br><span class="hljs-keyword">String</span>类型是二进制安全的。意味着Redis的<span class="hljs-keyword">string</span>可以包含任何数据。比如jpg图片或者序列化的对象。<br><br>字符串value最多可以是<span class="hljs-number">512</span>M<br></code></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">简单动态字符串(Simple <span class="hljs-keyword">Dynamic</span> <span class="hljs-keyword">String</span>,缩写SDS)，类似于Java的ArrayList<br><br>当字符串长度小于<span class="hljs-number">1</span>M时，扩容都是加倍现有的空间，如果超过<span class="hljs-number">1</span>M，扩容时一次只会多扩<span class="hljs-number">1</span>M的空间。需要注意的是字符串最大长度为<span class="hljs-number">512</span>M。<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220117010527194.png" alt="image-20220117010527194"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）<br><br>底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。<br></code></pre></td></tr></table></figure><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">压缩链表zipList和快速链表<span class="hljs-keyword">quick</span>List<br><br>链表元素较少的情况时使用一块连续的内存存储，这个结构是zipList，它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br><br>数据量比较多的时候才会改成<span class="hljs-keyword">quick</span>List，因为普通的链表需要的附加指针空间太大，会比较浪费空间。<br><br>将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220117010926381.png" alt="image-20220117010926381"></p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">与<span class="hljs-built_in">list</span>类似是一个列表的功能，特殊之处在于<span class="hljs-built_in">set</span>是可以自动排重的<br><br>Redis的<span class="hljs-built_in">Set</span>是<span class="hljs-built_in">string</span>类型的无序集合。它底层其实是一个value为<span class="hljs-built_in">null</span>的hash表，所以添加，删除，查找的复杂度都是O(<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-type">Set</span>数据结构是<span class="hljs-built_in">dict</span>字典，字典是用哈希表实现的。<br><br>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。<br><br>Redis的<span class="hljs-built_in">set</span>结构也是一样，它的内部也使用<span class="hljs-built_in">hash</span>结构，所有的value都指向同一个内部值。<br></code></pre></td></tr></table></figure><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs qml">是一个键值对集合<br><br>一个<span class="hljs-built_in">string</span>类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Object</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">压缩链表zipList和哈希表hashTable<br><br>当<span class="hljs-meta">field</span>-value长度较短且个数较少时，使用ziplist，否则使用hashtable。<br></code></pre></td></tr></table></figure><h1 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h1><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf">有序集合zset与普通集合<span class="hljs-built_in">set</span>非常相似，是一个没有重复元素的字符串集合。<br><br>不同之处是有序集合的每个成员都关联了一个评分（<span class="hljs-built_in">score</span>）,这个评分（<span class="hljs-built_in">score</span>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。<br><br>因为元素是有序的, 所以你也可以很快的根据评分（<span class="hljs-built_in">score</span>）或者次序（<span class="hljs-built_in">position</span>）来获取一个范围的元素。<br><br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。<br></code></pre></td></tr></table></figure><h2 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml">Hash和跳跃表skipList<br><br>hash的作用就是关联元素value和权重<span class="hljs-symbol">score</span>，保障元素value的唯一性，可以通过元素value找到相应的<span class="hljs-symbol">score</span>值。<br><br>跳跃表，跳跃表的目的在于给元素value排序，根据<span class="hljs-symbol">score</span>的范围获取元素列表。<br></code></pre></td></tr></table></figure><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p><img src="https://upload-images.jianshu.io/upload_images/23305082-255a27dd65397139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1061/format/webp" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">从高层索引寻找，如果发现小于则跳跃，如果发现大于则向低一层索引查找，直到查找到为止。<br></code></pre></td></tr></table></figure><h1 id="BitMaps"><a href="#BitMaps" class="headerlink" title="BitMaps"></a>BitMaps</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">用于布隆过滤器<br></code></pre></td></tr></table></figure><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">统计不重复数据，用于大数据基数统计<br></code></pre></td></tr></table></figure><h1 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">适合存经纬度，基于Z<span class="hljs-keyword">set</span>实现<br></code></pre></td></tr></table></figure><h1 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">内存表kafka，用于消息的订阅发布<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存淘汰算法和淘汰策略</title>
    <link href="/2022/01/24/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E5%92%8C%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2022/01/24/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E5%92%8C%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="常用淘汰算法"><a href="#常用淘汰算法" class="headerlink" title="常用淘汰算法"></a>常用淘汰算法</h1><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">First</span> <span class="hljs-built_in">In</span> <span class="hljs-built_in">First</span> <span class="hljs-built_in">Out</span>，先进先出<br>根据缓存被存储的时间，离当前最远的数据优先被淘汰<br></code></pre></td></tr></table></figure><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Least</span> Recently Used，最近最少使用。<br>算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 新数据插到链表头部<br><span class="hljs-bullet">2.</span> 每当缓存命中，则将数据移动到链表头部<br><span class="hljs-bullet">3.</span> 当链表满时，将链表尾部的数据丢弃<br></code></pre></td></tr></table></figure><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Least</span> Frequently Used，最不经常使用算法，在一段时间内，数据被使用次数最少的，优先被淘汰<br></code></pre></td></tr></table></figure><h1 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h1><h2 id="摆烂型"><a href="#摆烂型" class="headerlink" title="摆烂型"></a>摆烂型</h2><h3 id="noeviction"><a href="#noeviction" class="headerlink" title="noeviction"></a>noeviction</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">当内存限制达到时，谁也不删除，返回错误<br></code></pre></td></tr></table></figure><h2 id="针对所有key"><a href="#针对所有key" class="headerlink" title="针对所有key"></a>针对所有key</h2><h3 id="allkeys-lru"><a href="#allkeys-lru" class="headerlink" title="allkeys-lru"></a>allkeys-lru</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">尝试回收最少使用的键，使得新添加的数据有空间存放<br></code></pre></td></tr></table></figure><h3 id="allkey-random"><a href="#allkey-random" class="headerlink" title="allkey-random"></a>allkey-random</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">回收随机的键，使得新添加的数据有空间存放<br></code></pre></td></tr></table></figure><h2 id="针对过期key"><a href="#针对过期key" class="headerlink" title="针对过期key"></a>针对过期key</h2><h3 id="volatile-lru"><a href="#volatile-lru" class="headerlink" title="volatile-lru"></a>volatile-lru</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">尝试回收最少使用的键，使得新添加的数据有空间存放，但是仅限于在过期集合的键<br></code></pre></td></tr></table></figure><h3 id="volatile-random"><a href="#volatile-random" class="headerlink" title="volatile-random"></a>volatile-random</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">回收随机的键，使得新添加的数据有空间存放，但仅限于过期集合的键<br></code></pre></td></tr></table></figure><h3 id="volatile-ttl"><a href="#volatile-ttl" class="headerlink" title="volatile-ttl"></a>volatile-ttl</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">回收在过期集合的键，并且优先回收过期时间较短的键，使得新添加的数据有空间存放<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存穿透、击穿、雪崩</title>
    <link href="/2022/01/24/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/"/>
    <url>/2022/01/24/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><figure class="highlight gauss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">key</span>对应的数据在数据源中并不存在，每次针对此<span class="hljs-built_in">key</span>的请求从缓存中获取不到，请求都会压到数据源，从而可能压垮数据源。<br><br>比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220116205919743.png" alt="image-20220116205919743"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.对空值缓存<br>2.设置白名单<br>3.采用布隆过滤器<br>4.进行实时监控<br></code></pre></td></tr></table></figure><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">key对应的数据存在，但在redis中过期，此时又有大量的并发请求，而这些请求发现缓存过期又会从<span class="hljs-built_in">DB</span>中加载并设到缓存，这个时候可能会把<span class="hljs-built_in">DB</span>压垮<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220116210315495.png" alt="image-20220116210315495"></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 预先设置热门数据<br><span class="hljs-bullet">2.</span> 调整时长<br><span class="hljs-bullet">3.</span> 使用同步锁，在缓存失效并且面对大量请求时，只让一个请求去数据库请求数据并设到缓存中，其他请求等待这个请求缓存后的结果。<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220116210530279.png" alt="image-20220116210530279"></p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">在缓存击穿的基础上有更多的<span class="hljs-built_in">key</span>值过期<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220116210639894.png" alt="image-20220116210639894"></p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>.多级缓存架构 nginx缓存+redis缓存+其他缓存<br><span class="hljs-number">2</span>.使用锁或队列，让请求在可承受范围内访问<span class="hljs-built_in">DB</span>，并设到缓存中方便其他请求使用<br><span class="hljs-number">3</span>.将缓存失效时间分散开<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁的实现</title>
    <link href="/2022/01/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/01/24/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="满足的条件"><a href="#满足的条件" class="headerlink" title="满足的条件"></a>满足的条件</h1><h2 id="互斥性"><a href="#互斥性" class="headerlink" title="互斥性"></a>互斥性</h2><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">任意时刻，只有一个客户端持有锁<br></code></pre></td></tr></table></figure><h2 id="不会发生死锁"><a href="#不会发生死锁" class="headerlink" title="不会发生死锁"></a>不会发生死锁</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。<br></code></pre></td></tr></table></figure><h2 id="解铃还须系铃人"><a href="#解铃还须系铃人" class="headerlink" title="解铃还须系铃人"></a>解铃还须系铃人</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。<br></code></pre></td></tr></table></figure><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">加锁和解锁必须具有原子性<br></code></pre></td></tr></table></figure><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="一、多个客户端申请获取锁"><a href="#一、多个客户端申请获取锁" class="headerlink" title="一、多个客户端申请获取锁"></a>一、多个客户端申请获取锁</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">即执行多个setnx语句<br></code></pre></td></tr></table></figure><h2 id="二、获取成功"><a href="#二、获取成功" class="headerlink" title="二、获取成功"></a>二、获取成功</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">即执行setnx语句成功后的客户端，其他客户端等待重试<br></code></pre></td></tr></table></figure><h2 id="三、执行业务逻辑"><a href="#三、执行业务逻辑" class="headerlink" title="三、执行业务逻辑"></a>三、执行业务逻辑</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">从<span class="hljs-built_in">db</span>获取数据，放入缓存<br></code></pre></td></tr></table></figure><h2 id="四、释放锁"><a href="#四、释放锁" class="headerlink" title="四、释放锁"></a>四、释放锁</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">执行<span class="hljs-selector-tag">del</span>语句<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以上步骤解决了互斥性<br></code></pre></td></tr></table></figure><h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果业务逻辑出现异常，导致锁无法释放<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">设置锁的过期时间，解决死锁问题<br></code></pre></td></tr></table></figure><h1 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h1><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode">在解决问题一后，可能存在释放了其他客户端上的锁，现象如下：<br><br><span class="hljs-number">1.</span> i<span class="hljs-symbol">ndex1</span>业务逻辑没执行完，<span class="hljs-number">3</span>秒后锁被自动释放。<br><span class="hljs-number">2.</span> i<span class="hljs-symbol">ndex2</span>获取到锁，执行业务逻辑，<span class="hljs-number">3</span>秒后锁被自动释放。<br><span class="hljs-number">3.</span> i<span class="hljs-symbol">ndex3</span>获取到锁，执行业务逻辑<br><span class="hljs-number">4.</span> i<span class="hljs-symbol">ndex1</span>业务逻辑执行完成，开始调用del释放锁，这时释放的是i<span class="hljs-symbol">ndex3</span>的锁，导致i<span class="hljs-symbol">ndex3</span>的业务只执行<span class="hljs-number">1</span>s就被别人释放。<br><br>最终等于没锁的情况。<br></code></pre></td></tr></table></figure><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">setnx获取锁时，设置一个指定的唯一值（例如：<span class="hljs-built_in">uuid</span>）；释放前获取这个值，判断是否自己的锁<br><br>解决了上锁和释放锁是同一个客户端<br></code></pre></td></tr></table></figure><h1 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">在解决问题二后，删除操作缺乏原子性，现象如下：<br><br>可能存在有一个客户端刚好执行到删除<span class="hljs-selector-tag">del</span>语句，而且已经完成了uuid的判断，但已经过期，此时第二个客户端开始上锁，可恰好第一个客户端开始执行<span class="hljs-selector-tag">del</span>语句，导致第二个客户端的lock被删除<br></code></pre></td></tr></table></figure><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">LUA脚本保证删除的原子性<br><br>解决了原子性<br></code></pre></td></tr></table></figure><h1 id="与Zookeeper分布式锁的差异"><a href="#与Zookeeper分布式锁的差异" class="headerlink" title="与Zookeeper分布式锁的差异"></a>与Zookeeper分布式锁的差异</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">Redis性能高，但是需要多重优化，而且客户端需要不断去尝试获取锁，比较耗性能<br>Zookeeper可靠性强，不需要不断主动尝试获取锁，只需要负责监听前一个节点即可，性能开销较小<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>持久化机制</title>
    <link href="/2022/01/24/%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/01/24/%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">Redis是基于内存运行的，将redis数据写入到硬盘这一过程就叫持久化<br></code></pre></td></tr></table></figure><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Redis <span class="hljs-keyword">Database</span> <br><br>在指定的时间间隔内将某一时刻的内存快照（<span class="hljs-keyword">Snapshot</span>），以二进制的方式写入磁盘<br></code></pre></td></tr></table></figure><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><p><img src="/image/image-20220117141431659.png" alt="image-20220117141431659"></p><h2 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">Redis会单独创建（<span class="hljs-keyword">fork</span>）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br><br>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220117142306007.png" alt="image-20220117142306007"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.适合大规模的数据恢复<br>2.对数据完整性和一致性要求不高<br>3.节省磁盘空间<br>4.恢复速度快<br></code></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.最后一次持久化后的数据可能丢失。<br>2.使用了写时复制技术，会比较消耗性能<br></code></pre></td></tr></table></figure><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Append</span> Of <span class="hljs-keyword">File</span><br><br>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作<br></code></pre></td></tr></table></figure><h2 id="持久化流程-1"><a href="#持久化流程-1" class="headerlink" title="持久化流程"></a>持久化流程</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>客户端的请求写命令会被append追加到AOF缓冲区内<br><span class="hljs-number">2.</span>AOF缓冲区根据AOF持久化策略[<span class="hljs-keyword">always</span>,everysec,<span class="hljs-keyword">no</span>]将操作sync同步到磁盘的AOF文件中<br><span class="hljs-number">3.</span>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量<br><span class="hljs-number">4.</span>Redis服务重启时，会重新<span class="hljs-keyword">load</span>加载AOF文件中的写操作达到数据恢复的目的<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220117145032238.png" alt="image-20220117145032238"></p><h2 id="同步频率设置"><a href="#同步频率设置" class="headerlink" title="同步频率设置"></a>同步频率设置</h2><ul><li>appendfsync always</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br></code></pre></td></tr></table></figure><ul><li>appendfsync everysec</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br></code></pre></td></tr></table></figure><ul><li>appendfsync no</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">redis不主动进行同步，把同步时机交给操作系统。<br></code></pre></td></tr></table></figure><h2 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.备份机制更稳健，丢失数据概率更低。<br>2.读的日志文本，通过操作AOF稳健，可以处理误操作。<br></code></pre></td></tr></table></figure><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.比起RDB占用更多的磁盘空间。<br>2.恢复备份速度要慢。<br>3.每次读写都同步的话，有一定的性能压力。<br>4.存在个别Bug，造成恢复不能。<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220117145601472.png" alt="image-20220117145601472"></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）<br></code></pre></td></tr></table></figure><h1 id="究竟使用哪个？"><a href="#究竟使用哪个？" class="headerlink" title="究竟使用哪个？"></a>究竟使用哪个？</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">官方推荐两个都启用。<br><br>如果对数据不敏感，可以选单独用RDB。<br><br>不建议单独用 AOF，因为可能会出现<span class="hljs-keyword">Bug。</span><br><span class="hljs-keyword"></span><br>如果只是做纯内存缓存，可以都不用。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2022/01/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2022/01/24/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>位图中的每一个槽只占1 bit的内存，所以即便面对10亿数据也只占用119多M的内存</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">在面临大数据的情况下，判断一个数是否存在<br></code></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">将判断的值分多个<span class="hljs-built_in">hash</span>函数进行计算，如果其中有一个<span class="hljs-built_in">hash</span>函数的值不等于1，则可以判定这个数不存在；反之大概率存在<br></code></pre></td></tr></table></figure><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li><p>占用内存小</p></li><li><p>增加和查询的时间复杂度为：O(K)，K为哈希函数的个数</p></li><li><p>哈希函数相互之间没有关系，方便硬件并行运算</p></li><li><p>布隆过滤器本身不存储元素本身，在某些对保密要求比较严格的场合有很大优势</p></li><li><p>数据量很大时，布隆过滤器可以表示全集</p></li><li><p>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</p></li><li><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1></li><li><p>存在误判率</p></li><li><p>不能获取元素本身</p></li><li><p>一般情况下不能从布隆过滤器删除元素</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL原理</title>
    <link href="/2022/01/24/MySQL%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/24/MySQL%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h1><p>使用索引查找数据性能很快，避免了全表扫描时的多次磁盘IO。</p><p>但是，使用索引实际上也需要在索引中查找数据，而且数据量和表中的是一样的</p><p>那为什么索引就能快呢？</p><p>这就跟索引使用了哪些数据结构有关</p><p>而索引是帮助Mysql高效获取数据的 <strong>排好序</strong> 的 <strong>数据结构</strong></p><h1 id="二、索引分类"><a href="#二、索引分类" class="headerlink" title="二、索引分类"></a>二、索引分类</h1><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>主键自带索引效果，也就意味着通过主键来查询表中的记录，性能是非常好的</p><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>为普通的列创建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql"># 格式<br>create index 索引名称 on 表名(列名)<br># 例子<br>create index idx_name on employees(name)<br></code></pre></td></tr></table></figure><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>就像是唯一列，列中的数据是唯一的。性能比普通的性能更好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 格式<br>create unique index 索引名称 on 表名(列名)<br># 例子<br>create unique index index_name on employees(name)<br></code></pre></td></tr></table></figure><h2 id="联合索引（组合索引）"><a href="#联合索引（组合索引）" class="headerlink" title="联合索引（组合索引）"></a>联合索引（组合索引）</h2><p>一次性维表中的多个字段一起创建索引，但建议不要超过5个；<strong>最左前缀法则（如何命中联合索引中的索引列）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 格式<br>create index 索引名称 on 表名(列1,列2,列3)<br># 例子<br>create index idx_name_age_position on employees(name,age,position)<br></code></pre></td></tr></table></figure><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>MyISAM存储引擎支持全文索引。在实际开发中，并不会使用MySQL提供的MyISAM存储引擎的全文索引功能来实现全文查找，而是会通过使用第三方的搜索引擎中间件比如说ElasicSearch（使用较多）、Solr</p><h1 id="三、InnoDB和MyISAM的区别"><a href="#三、InnoDB和MyISAM的区别" class="headerlink" title="三、InnoDB和MyISAM的区别"></a>三、InnoDB和MyISAM的区别</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><ul><li>也称<strong>聚簇索引</strong>——把索引和数据存放在一个**文件(.ibd)**中，通过找到所有后就能直接在索引树上的叶子节点中获取完整的数据</li><li>可以实现行/表锁</li><li>支持外键</li><li>支持事务</li></ul><img src="/image/image-20211113144109591.png" alt="image-20211113144109591" style="zoom:50%;" /><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><ul><li>也称<strong>非聚簇索引</strong>——把索引和数据分开放到(.myi)和(.myd)文件中，查找到索引后还要去另一个文件中查找数据，相比聚簇索引而言查询性能会稍微差一些</li><li>天然支持表锁</li><li>支持全文索引</li><li>不支持外键</li><li>不支持事务</li></ul><img src="/image/image-20211113143823232.png" alt="image-20211113143823232" style="zoom:50%;" /><h1 id="四、索引常问面试题"><a href="#四、索引常问面试题" class="headerlink" title="四、索引常问面试题"></a>四、索引常问面试题</h1><h2 id="为什么非主键索引的叶子节点存放的数据是主键值"><a href="#为什么非主键索引的叶子节点存放的数据是主键值" class="headerlink" title="为什么非主键索引的叶子节点存放的数据是主键值"></a>为什么非主键索引的叶子节点存放的数据是主键值</h2><img src="/image/image-20211113144954316.png" alt="image-20211113144954316" style="zoom:50%;" /><p><strong>节约存储空间。</strong>避免存储冗余重复的数据</p><p><strong>维护简单。</strong>因为id是唯一且难以变更的，数据的增删很难会影响到id的变化</p><p>​                   倘若存储的数据还包含其他非主键数据，当其被修改时不仅在数据库中需要修改，而且还需要对索引进行修改</p><h2 id="为什么InnoDB表必须创建主键"><a href="#为什么InnoDB表必须创建主键" class="headerlink" title="为什么InnoDB表必须创建主键"></a>为什么InnoDB表必须创建主键</h2><p> <strong>增加性能。</strong>如果InnoDB表不创建主键，MySQL优化器会自动创建一个虚拟的主键，于是普通索引（辅助索引）就会使用这个虚拟主键进行查找，并且创建虚拟主键则会增加性能开销</p><h2 id="为什么使用主键时推荐使用整型的自增主键"><a href="#为什么使用主键时推荐使用整型的自增主键" class="headerlink" title="为什么使用主键时推荐使用整型的自增主键"></a>为什么使用主键时推荐使用整型的自增主键</h2><ul><li><strong>使用整型</strong></li></ul><p><strong>避免不必要的开销。</strong>整型的数据大小是非常好比较的，如果使用字符串则需要进行依次编码后才能进行比较</p><ul><li><strong>使用自增</strong></li></ul><p><strong>避免不必要的开销。</strong>当使用了不规律的数据时，索引树需要通过<strong>自旋</strong>的方式使叶子节点从小到大-从左到右有序排列，而多次的<strong>自旋</strong>会给系统带来一定的性能开销</p><h1 id="五、联合索引和最左前缀法则"><a href="#五、联合索引和最左前缀法则" class="headerlink" title="五、联合索引和最左前缀法则"></a>五、联合索引和最左前缀法则</h1><h2 id="联合索引的存储结构"><a href="#联合索引的存储结构" class="headerlink" title="联合索引的存储结构"></a>联合索引的存储结构</h2><p>联合索引会使节点中存放的<strong>索引键增多</strong></p><img src="/image/image-20211113151449444.png" alt="image-20211113151449444" style="zoom:50%;" /><h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h2><p>表示一条sql语句在联合索引中有没有走索引（命中索引/不会全表扫描）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建联合索引<br>create index idex_a_b_c on table1(a,b,c)<br># 判断sql语句有没有命中索引<br><br># 命中a<br>select * from table1 where a = 10;<br># 命中a<br>select * from table1 where a = 10 and b = 20;<br># 命中a<br>select * from table1 where a = 10 and b = 20 and c = 30;<br># 未命中b，因为a没有被命中，所以b也不会被命中<br>select * from table1 where b = 10;<br># 未命中b也没命中c，因为a没有被命中，所以b也不会被命中，b没有被命中c也不会被命中<br>select * from table1 where b = 10 and c = 30;<br># 命中a但没有命中b，因为b没有被命中，所以c也不会被命中<br>select * from table1 where a = 10 and c = 30;<br># 既没有命中a，也没有命中b，更没有命中c<br>select * from table1 where c = 30;<br># 命中abc，mysql中有一个内部优化器，会做一次内部优化<br>select * from table1 where a = 10 and c = 30 and b = 20;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习</title>
    <link href="/2022/01/24/RabbitMQ%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/01/24/RabbitMQ%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="MQ（Message-Queue）是什么？"><a href="#MQ（Message-Queue）是什么？" class="headerlink" title="MQ（Message Queue）是什么？"></a>MQ（Message Queue）是什么？</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>实现系统间的解耦</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过利用高效的消息传递机制进行平台无关的数据交流，并基于数据通信进行分布式系统的集成</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="/image/image-20211225134539204.png" alt="image-20211225134539204"></p><ul><li>生成者：不断向消息队列中生产消息</li><li>消费者：不断向队列中获取消息</li><li>消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松地实现系统间解耦</li></ul><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">因此跨系统通讯时，首选消息队列<br></code></pre></td></tr></table></figure><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>如何实现，就用到了消息中间件</p><p><img src="/image/image-20211225135206345.png" alt="image-20211225135206345"></p><h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><p><img src="/image/image-20211225140413964.png" alt="image-20211225140413964"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="/image/image-20211225144002366.png" alt="image-20211225144002366"></p><p><img src="/image/image-20211225144024194.png" alt="image-20211225144024194"></p><p><img src="/image/image-20211225144417498.png" alt="image-20211225144417498"></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rabbitmq-plugins <span class="hljs-builtin-name">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">systemctl <span class="hljs-keyword">start</span> rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">systemctl status rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">systemctl <span class="hljs-keyword">restart</span> rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">systemctl <span class="hljs-keyword">stop</span> rabbitmq-<span class="hljs-built_in">server</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">journalctl </span>-xe 查看报错日志<br></code></pre></td></tr></table></figure><h1 id="管理命令和管理界面"><a href="#管理命令和管理界面" class="headerlink" title="管理命令和管理界面"></a>管理命令和管理界面</h1><p>通过自行配置开放端口号进入到WEB的管理界面</p><p>在没有WEB界面下，可以通过以下命令进行管理</p><p><img src="/image/image-20211225153705068.png" alt="image-20211225153705068"></p><h2 id="默认端口说明"><a href="#默认端口说明" class="headerlink" title="默认端口说明"></a>默认端口说明</h2><ul><li>15672(HTTP)：HTTP WEB界面端口</li><li>5672(AMQP)：TCP 通讯端口（Java操作时会用到的端口）</li><li>25672(CLUSTERING)：集群通讯</li></ul><h1 id="AMQP协议-1"><a href="#AMQP协议-1" class="headerlink" title="AMQP协议"></a>AMQP协议</h1><p>Advanced Message Queuing Protocal 高级消息队列协议是一个进程间传递异步消息的网路协议</p><p><img src="/image/image-20211225170524287.png" alt="image-20211225170524287"></p><p>Virtual Host 相当于MySQL中的库，操作时，常常为每一个应用建立一个虚拟主机</p><h1 id="七种消息发布模式"><a href="#七种消息发布模式" class="headerlink" title="七种消息发布模式"></a>七种消息发布模式</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.rabbitmq.com/getstarted.html<br></code></pre></td></tr></table></figure><h1 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello world</span><br></code></pre></td></tr></table></figure><p><img src="/image/image-20211226162905062.png" alt="image-20211226162905062"></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>登录</li></ul><h2 id="生成者"><a href="#生成者" class="headerlink" title="生成者"></a>生成者</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs json">package com.wu.helloworld;<br><br>import com.rabbitmq.client.Channel;<br>import com.rabbitmq.client.Connection;<br>import com.wu.utils.RabbitMQUtils;<br>import org.junit.Test;<br><br>import java.io.IOException;<br>import java.util.concurrent.TimeoutException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Haixin Wu</span><br><span class="hljs-comment"> * @date 2021/12/25 20:58</span><br><span class="hljs-comment"> * @since 1.0</span><br><span class="hljs-comment"> */</span><br>public class Provider &#123;<br>    @Test<br>    public void testSendMessage() throws IOException, TimeoutException &#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        <span class="hljs-comment">//从连接中创建一个通道对象</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 通道绑定对应的消息队列</span><br><span class="hljs-comment">         * 参数1：队列名称，如果队列不存在自动创建</span><br><span class="hljs-comment">         * 参数2：定义的队列是否持久化？持久化会将队列写入磁盘，重启后仍存在</span><br><span class="hljs-comment">         * 参数3：是否独占队列？独占表示一个队列只允许当前连接可用</span><br><span class="hljs-comment">         * 参数4：是否在消费完成后自动消除队列？</span><br><span class="hljs-comment">         * 参数5：附加参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(<span class="hljs-attr">&quot;hello&quot;</span>, false, false, false, null);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 发布消息</span><br><span class="hljs-comment">         * 参数1：交换机名称</span><br><span class="hljs-comment">         * 参数2：队列名称</span><br><span class="hljs-comment">         * 参数3：传递消息额外设置</span><br><span class="hljs-comment">         * 参数4：消息的具体内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(<span class="hljs-attr">&quot;&quot;</span>,<span class="hljs-attr">&quot;hello&quot;</span>,null,<span class="hljs-attr">&quot;hello rabbit&quot;</span>.getBytes());<br>        RabbitMQUtils.closeConnectionAndChanel(channel, connection);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="绑定队列和发送队列"><a href="#绑定队列和发送队列" class="headerlink" title="绑定队列和发送队列"></a>绑定队列和发送队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通道绑定对应的消息队列</span><br><span class="hljs-comment"> * 参数1：队列名称，如果队列不存在自动创建</span><br><span class="hljs-comment"> * 参数2：定义的队列是否持久化？持久化会将队列写入磁盘，重启后仍存在，仅是队列持久化，其中的消息内容并不会持久化</span><br><span class="hljs-comment"> * 参数3：是否独占队列？独占表示一个队列只允许当前连接可用</span><br><span class="hljs-comment"> * 参数4：是否在消费者消费完成（断开连接）后自动消除队列？</span><br><span class="hljs-comment"> * 参数5：附加参数</span><br><span class="hljs-comment"> */</span><br>channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发布消息</span><br><span class="hljs-comment"> * 参数1：交换机名称</span><br><span class="hljs-comment"> * 参数2：队列名称</span><br><span class="hljs-comment"> * 参数3：传递消息额外设置，例如可以传参MessageProperties.PERSISTENT_TEXT_PLAIN表示队列中的消息持久化</span><br><span class="hljs-comment"> * 参数4：消息的具体内容</span><br><span class="hljs-comment"> */</span><br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;hello rabbit&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.helloworld;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/25 21:20</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//创建连接mq的连接工厂对象</span><br>        Connection connection = RabbitMQUtils.getConnection();<br>        <span class="hljs-comment">//从连接中创建一个通道对象</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 通道绑定对应的消息队列</span><br><span class="hljs-comment">         * 参数1：队列名称，如果队列不存在自动创建</span><br><span class="hljs-comment">         * 参数2：定义的队列是否持久化？持久化会将队列写入磁盘，重启后仍存在</span><br><span class="hljs-comment">         * 参数3：是否独占队列？独占表示一个队列只允许当前连接可用</span><br><span class="hljs-comment">         * 参数4：是否在消费者消费完成（断开连接）后自动消除队列？</span><br><span class="hljs-comment">         * 参数5：附加参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消费消息</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：开始消息时的自动确认机制</span><br><span class="hljs-comment">         * 参数3：消费时的回调接口</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 最后一个参数：消息队列中取出的消息</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;new String(body) = &quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//不建议关闭，因为消费者要一直监听</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="任务模型"><a href="#任务模型" class="headerlink" title="任务模型"></a>任务模型</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Work queues</span><br></code></pre></td></tr></table></figure><p><img src="/image/image-20211226162919813.png" alt="image-20211226162919813"></p><h2 id="平均消费消息"><a href="#平均消费消息" class="headerlink" title="平均消费消息"></a>平均消费消息</h2><h3 id="生成者-1"><a href="#生成者-1" class="headerlink" title="生成者"></a>生成者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.task;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/26 16:44</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">taskProviderTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">null</span>,(i + <span class="hljs-string">&quot; hello task&quot;</span>).getBytes());<br>        &#125;<br>        RabbitMQUtils.closeConnectionAndChanel(channel, connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.task;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/26 16:44</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Customer1: &quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.task;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/26 16:45</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        channel.queueDeclare(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Customer2: &quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20211226170247634.png" alt="image-20211226170247634" style="zoom: 50%;" /><img src="/image/image-20211226170302705.png" alt="image-20211226170302705" style="zoom:50%;" /></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">默认情况下，RabbitMQ在任务模型下会将消息按顺序发送给下一个使用者。<br><br>如果消息总量能够整除消费者的数量，那么每个消费者都能够收到相同数量的消息。这种分发消息的方式成为循环。<br><br>但是对于存在一个消费者快，一个消费者慢的情况而言，循环分发消息的方式就不适应了。<br></code></pre></td></tr></table></figure><h2 id="消息自动确认机制"><a href="#消息自动确认机制" class="headerlink" title="消息自动确认机制"></a>消息自动确认机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在默认的消息消费的机制（平均分配）下，代表着开始消息时的自动确认机制的第二参数，是开启的，</span><br><span class="hljs-comment"> * 这种情况下它不关心你的业务是否处理完，消息在接收到消息时会自动地向消息队列中表示确认。</span><br><span class="hljs-comment"> * 举例说明：如果分配给该消费者5个消息，此时消费者无论消息是否完成都会自动地向消息队列中表示确认，</span><br><span class="hljs-comment"> * 如果进行到第3个消息时宕机了，剩下的2个消息就会被丢失了，这并不是我们希望发生的</span><br><span class="hljs-comment"> */</span><br>channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;Customer2: &quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="避免信息丢失的方法"><a href="#避免信息丢失的方法" class="headerlink" title="避免信息丢失的方法"></a>避免信息丢失的方法</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不能让消息队列将消息一次性地给消费者，让消息一个一个地来，所以就让消息通道中只有一个消息</span><br>channel.basicQos(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关闭消息确认机制</span><br>channel.basicConsume(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-keyword">false</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Customer1: &quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>      &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 手动确认消息。如果服务器突然宕机，未确认的消息就会重新回到消息队列中等待消费</span><br><span class="hljs-comment">// 第一个参数，标记为手动确认消息标识</span><br><span class="hljs-comment">// 第二个参数，是否开启多消息同时确认，false每次确认一个。因为通道中每次只有一个消息，所以此处设为false</span><br>channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><h2 id="能者多劳消费消息"><a href="#能者多劳消费消息" class="headerlink" title="能者多劳消费消息"></a>能者多劳消费消息</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过上例方法不仅能够实现避免消息丢失，而且还能实现能者多劳。<br></code></pre></td></tr></table></figure><img src="/image/image-20211229225000769.png" alt="image-20211229225000769" style="zoom: 50%;" /><img src="/image/image-20211229225016640.png" alt="image-20211229225016640" style="zoom:50%;" /><h1 id="广播-发布-订阅模型"><a href="#广播-发布-订阅模型" class="headerlink" title="广播/发布/订阅模型"></a>广播/发布/订阅模型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">Publish/Subscribe<br></code></pre></td></tr></table></figure><p><img src="/image/image-20211230202722263.png" alt="image-20211230202722263"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">交换机和队列的自动生成取决于消费者<br></code></pre></td></tr></table></figure><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>注册</li><li>提交订单时，既要与订单表进行交互，也要和库存进行交互</li><li>生成日志</li></ul><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.fanout;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/30 20:34</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 将通道指明指定交换机</span><br><span class="hljs-comment">         * 参数1.交换机名称</span><br><span class="hljs-comment">         * 参数2.交换机类型</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>, <span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 发送消息</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;faount type message&quot;</span>.getBytes());<br>        RabbitMQUtils.closeConnectionAndChanel(channel, connection);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.fanout;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/30 20:42</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 通道绑定交换机</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>, <span class="hljs-string">&quot;fanout&quot;</span>);<br>        <span class="hljs-comment">// 临时队列</span><br>        String queueName = channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 绑定交换机和队列</span><br>        channel.queueBind(queueName, <span class="hljs-string">&quot;logs&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 消费消息</span><br>        channel.basicConsume(queueName, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者1：&quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20211230205302790.png" alt="image-20211230205302790"></p><p><img src="/image/image-20211230205309723.png" alt="image-20211230205309723"></p><h1 id="路由模型"><a href="#路由模型" class="headerlink" title="路由模型"></a>路由模型</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Routing</span><br></code></pre></td></tr></table></figure><p><img src="/image/image-20211231161512169.png" alt="image-20211231161512169"></p><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>日志打印，根据日志类型分发到不同的消费者中去</li></ul><h2 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.direct;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/31 16:20</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 通过通道声明交换机  参数1：交换机名称  参数2：路由模式</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">// 发送消息</span><br>        String routingKey = <span class="hljs-string">&quot;info&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;logs_direct&quot;</span>, routingKey, <span class="hljs-keyword">null</span>, (<span class="hljs-string">&quot;这是direct模型发布的基于route key：[&quot;</span>+routingKey+<span class="hljs-string">&quot;]发送的消息&quot;</span>).getBytes());<br>        RabbitMQUtils.closeConnectionAndChanel(channel, connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.direct;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/31 16:26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 通道声明交换机和交换机的类型</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">// 创建一个临时队列</span><br>        String queue = channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 基于route key绑定队列和交换机</span><br>        channel.queueBind(queue, <span class="hljs-string">&quot;logs_direct&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>        <span class="hljs-comment">// 获取队列中的消息</span><br>        channel.basicConsume(queue, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者1：&quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.direct;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/31 16:26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 通道声明交换机和交换机的类型</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">// 创建一个临时队列</span><br>        String queue = channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 基于route key绑定队列和交换机</span><br>        channel.queueBind(queue, <span class="hljs-string">&quot;logs_direct&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(queue, <span class="hljs-string">&quot;logs_direct&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>        channel.queueBind(queue, <span class="hljs-string">&quot;logs_direct&quot;</span>, <span class="hljs-string">&quot;warning&quot;</span>);<br>        <span class="hljs-comment">// 获取队列中的消息</span><br>        channel.basicConsume(queue, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者1：&quot;</span> + <span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20211231164051971.png" alt="image-20211231164051971"></p><p><img src="/image/image-20211231164117009.png" alt="image-20211231164117009"></p><p><img src="/image/image-20211231164148933.png" alt="image-20211231164148933"></p><p><img src="/image/image-20211231164155421.png" alt="image-20211231164155421"></p><h1 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h1><p><img src="/image/image-20220101141004814.png" alt="image-20220101141004814"></p><h2 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">只有主题模型才支持通配符<br></code></pre></td></tr></table></figure><h2 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.topics;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 14:00</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        String routeKey = <span class="hljs-string">&quot;user.save&quot;</span>;<br>        channel.basicPublish(<span class="hljs-string">&quot;topics&quot;</span>,routeKey,<span class="hljs-keyword">null</span>,(<span class="hljs-string">&quot;topic模型,routeKey: &quot;</span>+routeKey).getBytes());<br>        RabbitMQUtils.closeConnectionAndChanel(channel, connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.topics;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 14:14</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        String queue = channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.*&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者1： &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.topics;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><span class="hljs-keyword">import</span> com.wu.utils.RabbitMQUtils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 14:14</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Connection connection = RabbitMQUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>        String queue = channel.queueDeclare().getQueue();<br>        channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.#&quot;</span>);<br>        channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者2： &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220101142446275.png" alt="image-20220101142446275"></p><p><img src="/image/image-20220101142455176.png" alt="image-20220101142455176"></p><h1 id="与Spring-boot整合"><a href="#与Spring-boot整合" class="headerlink" title="与Spring boot整合"></a>与Spring boot整合</h1><h2 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-rabbitmq</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">180.76</span><span class="hljs-number">.136</span><span class="hljs-number">.123</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">13399</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">wu</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/wu_rabbitmq_study</span><br></code></pre></td></tr></table></figure><p><code>RabbitTemplate</code> 用来简化操作，注入即可</p><h1 id="Spring-boot点对点模型"><a href="#Spring-boot点对点模型" class="headerlink" title="Spring boot点对点模型"></a>Spring boot点对点模型</h1><h2 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.springbootrabbitmq;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@SpringBootTest(classes = RabbitmqApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqApplicationTests</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">// hello world</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者-4"><a href="#消费者-4" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.springbootrabbitmq.hello;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认是持久化、非独占、不是自动删除</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 14:47</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;hello&quot;, durable = &quot;false&quot;, autoDelete = &quot;true&quot;))</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloCustomer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spring-boot任务模型"><a href="#Spring-boot任务模型" class="headerlink" title="Spring boot任务模型"></a>Spring boot任务模型</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">任务模型中，Spring AMQP实现的默认方式是公平调度<br></code></pre></td></tr></table></figure><h2 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// work</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">workTest</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-string">&quot;work模型&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者-5"><a href="#消费者-5" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.springbootrabbitmq.work;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务模型中，Spring AMQP实现的默认方式是公平调度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 17:15</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkCustomer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者1：message = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者2：message = &quot;</span> + message);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spring-boot广播模型"><a href="#Spring-boot广播模型" class="headerlink" title="Spring boot广播模型"></a>Spring boot广播模型</h1><h2 id="生产者-5"><a href="#生产者-5" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// fanout</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fanoutTest</span><span class="hljs-params">()</span></span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;logs&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;fanout模型发送消息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者-6"><a href="#消费者-6" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.springbootrabbitmq.fanout;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 17:28</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutCustomer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue, // 创建临时队列</span><br><span class="hljs-meta">                    exchange = @Exchange(value = &quot;logs&quot;, type = &quot;fanout&quot;)// 指定交换机</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者1：message = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue, // 创建临时队列</span><br><span class="hljs-meta">                    exchange = @Exchange(value = &quot;logs&quot;, type = &quot;fanout&quot;)// 指定交换机</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者2：message = &quot;</span> + message);<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h1 id="Spring-boot路由模型"><a href="#Spring-boot路由模型" class="headerlink" title="Spring boot路由模型"></a>Spring boot路由模型</h1><h2 id="生产者-6"><a href="#生产者-6" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// routing</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">routingTest</span><span class="hljs-params">()</span></span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directs&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-string">&quot;发送error的key的路由信息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者-7"><a href="#消费者-7" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.springbootrabbitmq.routing;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 17:35</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoutingCustomer</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,// 创建临时队列</span><br><span class="hljs-meta">                    exchange = @Exchange(value = &quot;directs&quot;, type = &quot;direct&quot;),// 指定交换机</span><br><span class="hljs-meta">                    key = &#123;&quot;info&quot;,&quot;error&quot;,&quot;warn&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者1：message = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,// 创建临时队列</span><br><span class="hljs-meta">                    exchange = @Exchange(value = &quot;directs&quot;, type = &quot;direct&quot;),// 指定交换机</span><br><span class="hljs-meta">                    key = &#123;&quot;error&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者2：message = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spring-boot主题模型"><a href="#Spring-boot主题模型" class="headerlink" title="Spring boot主题模型"></a>Spring boot主题模型</h1><h2 id="生产者-7"><a href="#生产者-7" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// topics</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">topicsTest</span><span class="hljs-params">()</span></span>&#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.save&quot;</span>,<span class="hljs-string">&quot;user.save 消息&quot;</span>);<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.save.xx&quot;</span>,<span class="hljs-string">&quot;user.save.xx 消息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者-8"><a href="#消费者-8" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wu.springbootrabbitmq.topics;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Haixin Wu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/1 17:41</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopicsCustomer</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    exchange = @Exchange(type = &quot;topic&quot;, name = &quot;topics&quot;),</span><br><span class="hljs-meta">                    key = &#123;&quot;user.*&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者1 message = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    exchange = @Exchange(type = &quot;topic&quot;, name = &quot;topics&quot;),</span><br><span class="hljs-meta">                    key = &#123;&quot;user.#&quot;&#125;</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者2 message = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="MQ的应用场景"><a href="#MQ的应用场景" class="headerlink" title="MQ的应用场景"></a>MQ的应用场景</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p><img src="/image/image-20220101175143769.png" alt="image-20220101175143769"></p><p><img src="/image/image-20220101175240992.png" alt="image-20220101175240992"></p><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p><img src="/image/image-20220101175525304.png" alt="image-20220101175525304"></p><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p><img src="/image/image-20220101175701881.png" alt="image-20220101175701881"></p>]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存模型</title>
    <link href="/2022/01/23/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/01/23/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JMM </span>即 <span class="hljs-keyword">Java </span>Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。<br></code></pre></td></tr></table></figure><h1 id="JMM主要体现在以下几个方面"><a href="#JMM主要体现在以下几个方面" class="headerlink" title="JMM主要体现在以下几个方面"></a>JMM主要体现在以下几个方面</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">保证指令不会受到线程上下文切换的影响<br></code></pre></td></tr></table></figure><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Atomicity</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> Object object = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (object) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">50000</span>; i1++) &#123;<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (object) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">50000</span>; i1++) &#123;<br>                    i--;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p><img src="/image/image-20220114133044894.png" alt="image-20220114133044894"></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">保证指令不会受 <span class="hljs-meta">cpu</span> 缓存的影响<br></code></pre></td></tr></table></figure><h3 id="问题引例"><a href="#问题引例" class="headerlink" title="问题引例"></a>问题引例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visibility</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span>  <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;);<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        run = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 代码最终并不会停下来，因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问，提高效率</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">它可以修饰成员变量和静态成员变量，用来避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 <span class="hljs-keyword">volatile</span> 变量都是直接操作主存<br></code></pre></td></tr></table></figure><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">一个线程对 <span class="hljs-keyword">volatile</span> 变量的修改对另一个线程而言是可见的，不能保证原子性，仅用在一个写线程，多个读线程的情况。<br></code></pre></td></tr></table></figure><h3 id="关于-synchronized-关键字"><a href="#关于-synchronized-关键字" class="headerlink" title="关于 synchronized 关键字"></a>关于 synchronized 关键字</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">synchronized</span> 语句块既可以保证代码块的原子性，同时也能保证代码块内变量的可见性。但缺点是 <span class="hljs-keyword">synchronized</span> 属于重量级操作，性能相对较低<br></code></pre></td></tr></table></figure><h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visibility</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span>  <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-comment">// ...</span><br>                System.out.println(<span class="hljs-number">1</span>); <span class="hljs-comment">// 为什么使用sout语句也能将线程停下来？</span><br>            &#125;<br>        &#125;);<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        run = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">// 因为sout语句内部使用了 synchronized 语句块</span><br>        print(x);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">保证指令不会受 <span class="hljs-meta">cpu</span> 指令并行优化的影响<br></code></pre></td></tr></table></figure><h3 id="引例-1"><a href="#引例-1" class="headerlink" title="引例"></a>引例</h3><img src="/image/image-20220114150908935.png" alt="image-20220114150908935" style="zoom:50%;" /><img src="/image/image-20220114150942383.png" alt="image-20220114150942383" style="zoom:50%;" /><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">出现 <span class="hljs-number">0</span> 的情况的现象叫做指令重排，是 <span class="hljs-keyword">JIT </span>编译器在运行时的一些优化，这个现象需要通过大量测试才能复现<br></code></pre></td></tr></table></figure><h3 id="解决指令重排"><a href="#解决指令重排" class="headerlink" title="解决指令重排"></a>解决指令重排</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">为 ready 参数添加 <span class="hljs-keyword">volatile</span> 关键字修饰，确保可见性，避免指令重排<br></code></pre></td></tr></table></figure><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3> <img src="/image/image-20220114152704260.png" alt="image-20220114152704260" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存结构</title>
    <link href="/2022/01/23/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/23/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/image-20220115135430504.png" alt="image-20220115135430504"></p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>线程私有</p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的 字节码的<strong>行号指示器</strong>。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处 理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h1 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h1><p>线程私有</p><p>虚拟机栈描述的是Java方法执行的线程内存模型：</p><p>每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>线程私有</p><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，</p><p>其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。 </p><h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>线程共享，同时是垃圾收集器管理的内存区域</p><p>Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。</p><p>此内存区域的唯一目的就是存放对象实例</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>线程共享</p><p>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 </p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2022/01/23/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/01/23/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/image-20220115135430504.png" alt="image-20220115135430504"></p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>在对象的创建过程中，完成了检查阶段</p><img src="/image/image-20220115141354723.png" alt="image-20220115141354723" style="zoom: 67%;" /><ul><li>加载 （Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化 （Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p>其中验证、准备、解析三个部分统称为连接（Linking）</p><p>其中加载、验证、准备、解析、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始。</p><p>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs">请注意，这里笔者写的是 按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都 是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。<br><br>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段 尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部 分，这两个阶段的开始时间仍然保持着固定的先后顺序。<br></code></pre></td></tr></table></figure><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="第一个阶段——加载"><a href="#第一个阶段——加载" class="headerlink" title="第一个阶段——加载"></a>第一个阶段——加载</h2><ul><li>1）通过一个<strong>类的全限定名</strong>来获取定义此类的<strong>二进制字节流</strong>。</li><li>2）将这个<strong>字节流所代表的静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong>。</li><li>3）在内存中生成一个<strong>代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的<strong>访问入口</strong>。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></p><h2 id="第二个阶段——验证"><a href="#第二个阶段——验证" class="headerlink" title="第二个阶段——验证"></a>第二个阶段——验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是<strong>保证Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求</strong>，保证这些信息<strong>被当作代码运行后不会危害虚拟机自身的安全</strong></p><p>验证内容主要包含如下四点：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h2 id="第三个阶段——准备"><a href="#第三个阶段——准备" class="headerlink" title="第三个阶段——准备"></a>第三个阶段——准备</h2><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）<strong>分配内存</strong>并<strong>设置类变量初始值</strong>（对象创建过程的隐式创建）的阶段</p><p>假设一个类变量的定义为： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而把 value赋值为123的 putstatic 指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值 为123的动作要到<strong>类的初始化阶段</strong>才会被执行</p><h2 id="第四个阶段——解析"><a href="#第四个阶段——解析" class="headerlink" title="第四个阶段——解析"></a>第四个阶段——解析</h2><p>解析阶段是Java虚拟机将<strong>常量池内的符号引用</strong>替换为<strong>直接引用</strong>的过程</p><h2 id="第五个阶段——初始化"><a href="#第五个阶段——初始化" class="headerlink" title="第五个阶段——初始化"></a>第五个阶段——初始化</h2><p>类的初始化阶段是类加载过程的最后一个步骤，初始化阶段就是执行类构造器<clinit>()方法的过程</p><p><clinit>()方法是由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态语句块（static{}块）中的语句</strong>合并产生的</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>在类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。</p><p>而实现这个动作的代码被称为“类加载器”（Class Loader）</p><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却<strong>远超类加载阶段</strong>。</p><p>对于 任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>这句话表达地更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</strong></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap Class Loader），另外一种就是其他所有 </p><p>的类加载器。</p><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">Bootstrap</span> <span class="hljs-keyword">Class</span> Loader<br><br>这个类加载器使用C++语言实现，是虚拟机的一部分。<br><br>负责加载存放在&lt;JAVA_HOME&gt;\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库<br></code></pre></td></tr></table></figure><h3 id="其他所有的类加载器"><a href="#其他所有的类加载器" class="headerlink" title="其他所有的类加载器"></a>其他所有的类加载器</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">这些类加载器都由<span class="hljs-keyword">Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 </span><span class="hljs-keyword">java.lang.ClassLoader</span><br></code></pre></td></tr></table></figure><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Extension </span>Class Loader<br><br>这个类加载器是在类sun.misc.Launcher$<span class="hljs-keyword">ExtClassLoader中以Java代码的形式实现的。</span><br><span class="hljs-keyword"></span><br>主要负责加载&lt;<span class="hljs-keyword">JAVA_HOME&gt;\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</span><br><span class="hljs-keyword"></span><br>顾名思义，它是一种<span class="hljs-keyword">Java系统类库的扩展机制。用户可以将具有通用性的类库存放至ext目录里来扩展Java </span>SE的功能<br></code></pre></td></tr></table></figure><h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cos">Application <span class="hljs-keyword">Class</span> Loader<br><br>这个类加载器是在类sun.misc.Launcher<span class="hljs-built_in">$AppClassLoader</span>中以Java代码的形式实现的。<br><br>主要负责加载用户类路径上所有的类库<br></code></pre></td></tr></table></figure><h3 id="互相配合"><a href="#互相配合" class="headerlink" title="互相配合"></a>互相配合</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在<span class="hljs-keyword">JDK </span><span class="hljs-number">9</span>之前的<span class="hljs-keyword">Java应用都是由这三种类加载器互相配合来完成加载的，而各种类加载器之间的层次关系被称之为类加载器的“双亲委派模型”</span><br></code></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20201217213314510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGV5YW5iYW8=,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 40%;" /><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。<br><br>例如类java.lang.<span class="hljs-built_in">Object</span>，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此<span class="hljs-built_in">Object</span>类在程序的各种类加载器环境中都能够保证是同一个类。<br><br>如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.<span class="hljs-built_in">Object</span>的类，并放在程序的ClassPath中，那系统中就会出现多个不同的<span class="hljs-built_in">Object</span>类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<br>    <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过了</span><br>    Class c = findLoadedClass(name);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c = findBootstrapClassOrNull(name);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;<br>            <span class="hljs-comment">// 如果父类加载器抛出ClassNotFoundException</span><br>            <span class="hljs-comment">// 说明父类加载器无法完成加载请求</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// 在父类加载器无法加载时</span><br>            <span class="hljs-comment">// 再调用本身的findClass方法来进行类加载</span><br>            c = findClass(name);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>        resolveClass(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>垃圾收集</title>
    <link href="/2022/01/23/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <url>/2022/01/23/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs">很多教科书判断对象是否存活的算法是这样的：<br><br>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">引用计数算法（<span class="hljs-keyword">Reference</span> Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。<br></code></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。<br></code></pre></td></tr></table></figure><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">当前主流的商用程序语言（<span class="hljs-variable">Java</span>、<span class="hljs-built_in">C</span><span class="hljs-type">#</span>，上溯至前面提到的古老的<span class="hljs-variable">Lisp</span>）的内存管理子系统，都是通过可达性分析（<span class="hljs-variable">Reachability</span> <span class="hljs-variable">Analysis</span>）算法来判定对象是否存活的。<br><br>基本思路就是通过一系列称为“<span class="hljs-variable">GC</span> <span class="hljs-built_in">Roots</span>”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为<br>“引用链”（<span class="hljs-variable">Reference</span> <span class="hljs-variable">Chain</span>），如果某个对象到<span class="hljs-variable">GC</span> <span class="hljs-built_in">Roots</span>间没有任何引用链相连，或者用图论的话来说就是从<span class="hljs-variable">GC</span> <span class="hljs-built_in">Roots</span>到这个对象不可达时，则证明此对象是不可能再被使用的。<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220116140237501.png" alt="image-20220116140237501"></p><h2 id="GC-Roots对象"><a href="#GC-Roots对象" class="headerlink" title="GC Roots对象"></a>GC Roots对象</h2><ul><li>在<strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li><li>方法区中<strong>类静态属性</strong>引用的对象，譬如Java类的引用类型静态变量</li><li>方法区中<strong>常量</strong>引用的对象，譬如字符串常量池（String Table）里的引用</li><li>本地方法栈中<strong>JNI（Native方法）</strong>引用的对象</li><li>Java<strong>虚拟机内部</strong>引用的对象，譬如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器</li><li>所有被<strong>同步锁</strong>（synchronized关键字）持有的对象</li><li><strong>反应Java虚拟机内部情况</strong>的对象，譬如JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>强引用，类似<strong>Object obj = new Object()<strong>这种引用关系，只要强引用关系存在，垃圾收集器就</strong>永远不会收掉被引用的对象</strong></li><li>软引用，有用，但非必须的对象。在系统将要<strong>发生内存溢出异常前</strong>，会把这些对象列进回收范围之中<strong>进行第二次回收</strong></li><li>弱引用，描述那些非必须对象，但是它的强度比软引用更弱一些，<strong>每次都会被垃圾收集器收集</strong></li><li>虚引用，最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的只是为了能在这个对象<strong>被收集器回收时收到一个系统通知</strong></li></ul><h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less">即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：<br><br>如果对象在进行可达性分析后发现没有与<span class="hljs-selector-tag">GC</span> <span class="hljs-selector-tag">Roots</span>相连接的引用链，那它将会被第一次标记，<br><br>随后进行一次筛选，筛选的条件是此对象是否有必要执行<span class="hljs-selector-tag">finalize</span>()方法。<br><br>假如对象没有覆盖<span class="hljs-selector-tag">finalize</span>()方法(无药可救)，或者<span class="hljs-selector-tag">finalize</span>()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。<br></code></pre></td></tr></table></figure><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（ReferenceCounting <span class="hljs-built_in">GC</span>）和“追踪式垃圾收集”（Tracing <span class="hljs-built_in">GC</span>）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。<br><br>由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">部分收集（Partial <span class="hljs-built_in">GC</span>）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<br><br>新生代收集（Minor <span class="hljs-built_in">GC</span>/Young <span class="hljs-built_in">GC</span>）：指目标只是新生代的垃圾收集。<br><br>老年代收集（Major <span class="hljs-built_in">GC</span>/Old <span class="hljs-built_in">GC</span>）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major <span class="hljs-built_in">GC</span>”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。<br><br>混合收集（Mixed <span class="hljs-built_in">GC</span>）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">整堆收集（<span class="hljs-literal">Full</span> GC）：收集整个Java堆和方法区的垃圾收集。<br></code></pre></td></tr></table></figure><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><img src="/image/image-20220116151303548.png" alt="image-20220116151303548" style="zoom: 50%;" /><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">速度非常快<br></code></pre></td></tr></table></figure><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.是执行效率不稳定，如果<span class="hljs-keyword">Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低</span><br><span class="hljs-keyword"></span><br><span class="hljs-number">2</span>.容易产生内存碎片，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>比如上图中有一块较大的对象想存放，但是存放不下<br></code></pre></td></tr></table></figure><h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><img src="/image/image-20220116151526306.png" alt="image-20220116151526306" style="zoom:50%;" /><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">老年代<br></code></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">没有内存碎片<br></code></pre></td></tr></table></figure><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">添加了一步整理过程，需要移动对象，速度相对较慢<br></code></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><img src="/image/image-20220116151753876.png" alt="image-20220116151753876"></p><p><img src="/image/image-20220116151804412.png" alt="image-20220116151804412"></p><p><img src="/image/image-20220116151814884.png" alt="image-20220116151814884"></p><p><img src="/image/image-20220116151831573.png" alt="image-20220116151831573"></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">现在的商用Java虚拟机大多都优先采用了复制收集算法去回收新生代；但不适用于老年代，因为存活率高，会有较多的复制操作，效率将会降低<br></code></pre></td></tr></table></figure><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">不会产生内存碎片，速度也相对较快<br></code></pre></td></tr></table></figure><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">占用双倍的内存空间<br></code></pre></td></tr></table></figure><h1 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h1><h2 id="Java堆内存"><a href="#Java堆内存" class="headerlink" title="Java堆内存"></a>Java堆内存</h2><img src="/image/image-20220116153223569.png" alt="image-20220116153223569" style="zoom:50%;" /><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">使用Minor <span class="hljs-built_in">GC</span>/Young <span class="hljs-built_in">GC</span>，复制算法<br></code></pre></td></tr></table></figure><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">使用Major <span class="hljs-built_in">GC</span>/Old <span class="hljs-built_in">GC</span>，标记-整理算法<br></code></pre></td></tr></table></figure><h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">“<span class="hljs-literal">Stop</span> The World”这个词语也许听起来很酷，但这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。<br></code></pre></td></tr></table></figure><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Serial</span>收集器是最基础、历史最悠久的收集器，曾经（在JDK <span class="hljs-number">1.3</span><span class="hljs-number">.1</span>之前）是HotSpot虚拟机新生代收集器的唯一选择。<br><br>是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。<br><br>写到这里，笔者似乎已经把<span class="hljs-built_in">Serial</span>收集器描述成一个最早出现，但目前已经老而无用，食之无味，弃之可惜的“鸡肋”了，但事实上，迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的<br><br>在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以，<span class="hljs-built_in">Serial</span>收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。<br></code></pre></td></tr></table></figure><h3 id="运行示意图"><a href="#运行示意图" class="headerlink" title="运行示意图"></a>运行示意图</h3><p><img src="/image/image-20220116154120409.png" alt="image-20220116154120409"></p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Serial</span> <span class="hljs-built_in">Old</span>是<span class="hljs-type">Serial</span>收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。<br></code></pre></td></tr></table></figure><h3 id="运行示意图-1"><a href="#运行示意图-1" class="headerlink" title="运行示意图"></a>运行示意图</h3><p><img src="/image/image-20220116160108978.png" alt="image-20220116160108978"></p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">ParNew收集器实质上是<span class="hljs-built_in">Serial</span>收集器的多线程并行版本<br><br>ParNew收集器除了支持多线程并行收集之外，其他与<span class="hljs-built_in">Serial</span>收集器相比并没有太多创新之处，但它却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK <span class="hljs-number">7</span>之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：<br><br>除了<span class="hljs-built_in">Serial</span>收集器外，目前只有它能与CMS收集器配合工作。<br><br>自JDK <span class="hljs-number">9</span>开始，ParNew加CMS收集器的组合就不再是官方 推荐的服务端模式下的收集器解决方案了<br></code></pre></td></tr></table></figure><h3 id="运行示意图-2"><a href="#运行示意图-2" class="headerlink" title="运行示意图"></a>运行示意图</h3><p><img src="/image/image-20220116154549099.png" alt="image-20220116154549099"></p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">并行和并发都是并发编程中的专业名词，在谈论垃圾收集器的上下文语境中，它们可以理解为：<br><br>并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。<br><br>并发（<span class="hljs-keyword">Concurrent</span>）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。<br>由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。<br></code></pre></td></tr></table></figure><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Parallel</span> Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……<br><span class="hljs-keyword">Parallel</span> Scavenge的诸多特性从表面上看和ParNew非常相似<br></code></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">达到一个可控制的吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值<br></code></pre></td></tr></table></figure><p><img src="/image/image-20220116155443385.png" alt="image-20220116155443385"></p><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis<br><br>直接设置吞吐量大小的-XX：GCTimeRatio<br><br>自适应的调节策略-XX：+UseAdaptiveSizePolicy<br></code></pre></td></tr></table></figure><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Parallel</span> <span class="hljs-keyword">Old</span>是<span class="hljs-keyword">Parallel</span> Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。<br></code></pre></td></tr></table></figure><h3 id="运行示意图-3"><a href="#运行示意图-3" class="headerlink" title="运行示意图"></a>运行示意图</h3><p><img src="/image/image-20220116160223688.png" alt="image-20220116160223688"></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">CMS（Concurrent <span class="hljs-selector-tag">Mark</span> Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现<br><br>目前很大一部分的Java应用集中在互联网网站或者基于浏览器的<span class="hljs-selector-tag">B</span>/S系统的服务端上，这类应用通常都会较为 关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。<br></code></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以获取最短回收停顿时间为目标的收集器<br></code></pre></td></tr></table></figure><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><ul><li>初始标记</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">会触发<span class="hljs-variable">STW</span>，仅仅只是标记一下<span class="hljs-variable">GC</span> <span class="hljs-built_in">Roots</span>能直接关联到的对象，速度很快<br></code></pre></td></tr></table></figure><ul><li>并发标记</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">从<span class="hljs-variable">GC</span> <span class="hljs-built_in">Roots</span>的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行<br></code></pre></td></tr></table></figure><ul><li>重新标记</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">会触发STW，是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短<br></code></pre></td></tr></table></figure><ul><li>并发清除</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的<br></code></pre></td></tr></table></figure><h3 id="运行示意图-4"><a href="#运行示意图-4" class="headerlink" title="运行示意图"></a>运行示意图</h3><p><img src="/image/image-20220116161932917.png" alt="image-20220116161932917"></p><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> CMS收集器对处理器资源非常敏感。<br><br><span class="hljs-bullet">2.</span> CMS收集器无法处理“浮动垃圾”（Floating Garbage）<br><br><span class="hljs-bullet">3.</span> CMS是一款基于“标记-清除”算法实现的收集器，缺点非常明显，一是不稳定，二是有垃圾碎片<br></code></pre></td></tr></table></figure><h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Garbage</span> <span class="hljs-built_in">First</span>（简称<span class="hljs-variable">G1</span>）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于<span class="hljs-built_in">Region</span>的内存布局形式。<br><br><span class="hljs-variable">G1</span>是一款主要面向服务端应用的垃圾收集器。<br></code></pre></td></tr></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">同时注重吞吐量和低延迟，默认暂停目标 <span class="hljs-number">200</span><span class="hljs-variable">ms</span><br>超大堆内存，会将堆划分为多个大小相等的<span class="hljs-built_in">Region</span><br>整体上是标记<span class="hljs-operator">+</span>整理算法，两个区域之间是复制算法<br></code></pre></td></tr></table></figure><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">首先要有一个思想上的改变，在G1收集器出现之前的所有 其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor <span class="hljs-built_in">GC</span>），要么就是整个老年代（Major <span class="hljs-built_in">GC</span>），再要么就是整个Java堆（Full <span class="hljs-built_in">GC</span>）。<br><br>而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection <span class="hljs-built_in">Set</span>，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed <span class="hljs-built_in">GC</span>模式。<br></code></pre></td></tr></table></figure><h3 id="TAMS"><a href="#TAMS" class="headerlink" title="TAMS"></a>TAMS</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">G1</span>为每一个<span class="hljs-built_in">Region</span>设计了两个名为<span class="hljs-variable">TAMS</span>（<span class="hljs-built_in">Top</span> <span class="hljs-variable">at</span> <span class="hljs-variable">Mark</span> <span class="hljs-variable">Start</span>）的指针，把<span class="hljs-built_in">Region</span>中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。<br></code></pre></td></tr></table></figure><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原始快照<br></code></pre></td></tr></table></figure><h3 id="运行过程-1"><a href="#运行过程-1" class="headerlink" title="运行过程"></a>运行过程</h3><ul><li>初始标记</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">会触发<span class="hljs-variable">STW</span>，仅仅只是标记一下<span class="hljs-variable">GC</span> <span class="hljs-built_in">Roots</span>能直接关联到的对象，并且修改<span class="hljs-variable">TAMS</span>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的<span class="hljs-built_in">Region</span>中分配新对象。<br></code></pre></td></tr></table></figure><ul><li>并发标记</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">从<span class="hljs-variable">GC</span> <span class="hljs-built_in">Root</span>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。<br></code></pre></td></tr></table></figure><ul><li>最终标记</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">会触发STW，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。<br></code></pre></td></tr></table></figure><ul><li>筛选回收</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">会触发<span class="hljs-variable">STW</span>，负责更新<span class="hljs-built_in">Region</span>的统计数据，对各个<span class="hljs-built_in">Region</span>的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个<span class="hljs-built_in">Region</span> 构成回收集，然后把决定回收的那一部分<span class="hljs-built_in">Region</span>的存活对象复制到空的<span class="hljs-built_in">Region</span>中，再清理掉整个旧<span class="hljs-built_in">Region</span>的全部空间。<br></code></pre></td></tr></table></figure><h3 id="运行示意图-5"><a href="#运行示意图-5" class="headerlink" title="运行示意图"></a>运行示意图</h3><p><img src="/image/image-20220116164950814.png" alt="image-20220116164950814"></p><img src="/image/image-20220116170208884.png" alt="image-20220116170208884" style="zoom:50%;" /><h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><img src="/image/image-20220116170446228.png" alt="image-20220116170446228" style="zoom:33%;" /><img src="/image/image-20220116170502125.png" alt="image-20220116170502125" style="zoom:33%;" /><img src="/image/image-20220116170513803.png" alt="image-20220116170513803" style="zoom:33%;" /><h4 id="Young-Collection-Concurrent-Mark"><a href="#Young-Collection-Concurrent-Mark" class="headerlink" title="Young Collection + Concurrent Mark"></a>Young Collection + Concurrent Mark</h4><img src="/image/image-20220116170629991.png" alt="image-20220116170629991" style="zoom:33%;" /><h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><img src="/image/image-20220116170818400.png" alt="image-20220116170818400" style="zoom:33%;" /><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX: +UseG1GC</span><br><span class="hljs-deletion">-xx: G1HeapRegionSize = size</span><br><span class="hljs-deletion">-xx: MaxGCPauseMillis = time</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对象的创建过程</title>
    <link href="/2022/01/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/01/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、检查"><a href="#一、检查" class="headerlink" title="一、检查"></a>一、检查</h1><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">1.检查指令的参数是否能在常量池中定位到一个类的符号引用<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2.检查这个符号引用代表的类是否已被加载、解析和初始化过<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3.类加载检查是否符合《Java虚拟机规范》的全部约束要求<br></code></pre></td></tr></table></figure><h1 id="二、分配内存"><a href="#二、分配内存" class="headerlink" title="二、分配内存"></a>二、分配内存</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.选择分配方式。<span class="hljs-keyword">Java堆中的内存如果是绝对规整的，将会采用“指针碰撞”的分配方式；</span><br><span class="hljs-keyword"></span>反之采用“空闲列表”的分配方式。而<span class="hljs-keyword">Java堆中的内存是否规整又采用的垃圾收集器是否带有空间压缩整理的能力决定。</span><br><span class="hljs-keyword"></span><br>因此使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高校。<br>使用CMS这种基于清除算法的收集器时，采用比较复杂的空闲列表来分配内存<br><br><span class="hljs-number">2</span>.因为创建对象是虚拟机中非常频繁的行为，要解决线程问题。虚拟机提供了两种解决方案，一种是采用CAS配上失败重试的方式保证更新操作的原子性；另一种是为每个线程在<span class="hljs-keyword">Java堆中预先分配一块内存，称为本地线程分配缓存(Thread </span>Local Allocation <span class="hljs-keyword">Buffer, </span>TLAB)<br></code></pre></td></tr></table></figure><h1 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.隐式初始化。虚拟机将分配到不包括对象头在内的内存空间初始化为<span class="hljs-number">0</span>，如果这分配内存时采用TLAB解决线程安全问题，那么这一步会提前至TLAB分配时顺便进行。<br><br><span class="hljs-attribute">2</span>.显示初始化。虚拟机为对象头进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。从虚拟机的视角来看，一个新的对象已经产生了。<br><br><span class="hljs-attribute">3</span>.执行&lt;init&gt;()方法，按照开发者的意愿对对象进行初始化，此时一个真正可用的对象才算完全被构造出来。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Zk分布式锁的实现</title>
    <link href="/2022/01/17/Zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/01/17/Zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h1><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs">类似于Redis的setnx实现机制，但容易引起羊群效应<br></code></pre></td></tr></table></figure><h1 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h1><p><img src="/image/image-20220118000142610.png" alt="image-20220118000142610"></p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">因为读读之间是不需要排他的，所以基于Curator的ReentrantReadWriteLock可以实现读写锁提高性能<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 写入锁判断自己前面还有没有节点，如果没有就可以获取到锁，如果有就等待前面的节点释放锁。<br><br><span class="hljs-bullet">2.</span> 判断自己前面还有没有写入锁的节点，也就是前面的节点是否包含WRIT，如果有那么等待前面的节点释放锁。<br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf">写入锁在申请锁时写入的节点名称是这样的   xxxx-<span class="hljs-variable">__WRIT__00000000xxx</span> <br>例如：   <span class="hljs-variable">_c_9b6e456b</span>-<span class="hljs-number">94</span>fe-<span class="hljs-number">47</span>e7-b968-<span class="hljs-number">34027</span>c094b7d-<span class="hljs-variable">__WRIT__0000000006</span><br><br>读取锁在申请锁时写入的节点名称是这样的  xxxx-<span class="hljs-variable">__READ__00000000xxx</span> <br>例如：    <span class="hljs-variable">_c_9b6e456b90</span>-<span class="hljs-number">9</span>c33-<span class="hljs-number">6294665</span>cf525--b6448-<span class="hljs-variable">__READ__0000000005</span><br><br>区别就是写入锁的字符串包含WRIT，读取所包含READ<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
